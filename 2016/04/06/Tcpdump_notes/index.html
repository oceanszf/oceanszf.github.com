
 <!DOCTYPE HTML>
<html lang="default">
<head>
  <meta charset="UTF-8">
  
    <title>Tcpdump notes | Suzf Blog</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=3, minimum-scale=1">
    
    <meta name="author" content="Jeffrey Su">
    
    <meta name="description" content="tcpdump 是一个运行在命令行下的嗅探工具。它允许用户拦截和显示发送或收到过网络连接到该计算机的TCP/IP和其他数据包。tcpdump 是一个在BSD许可证下发布[2]的自由软件。
tcpdump 适用于大多数的类Unix系统 操作系统：包括Linux、Solaris、BSD、Mac OS X、HP-UX和AIX 等等。在这些系统中，tcpdump 需要使用libpcap这个捕捉数据的库。其在Windows下的版本称为WinDump；它需要WinPcap驱动，相当于在Linux平台下的libpcap.
用途tcpdump能够分析网络行为，性能和应用产生或接收网络流量。它支持针对网络层、协议、主机、网络或端口的过滤，并提供and、or、not等逻辑语句来帮助你去掉无用的信息，从而使用户能够进一步找出问题的根源。">
    
    
    
    
    <link rel="alternate" href="/atom.xml" title="Suzf Blog" type="application/atom+xml">
    
    
    <link rel="stylesheet" href="/css/style.css" type="text/css">
    
    <link rel="icon" href="/img/favicon.ico">
    <a href="https://github.com/suzf" target="_blank"><img style="position: absolute; top: 0; right: 0; border: 0;" src="https://camo.githubusercontent.com/38ef81f8aca64bb9a64448d0d70f1308ef5341ab/68747470733a2f2f73332e616d617a6f6e6177732e636f6d2f6769746875622f726962626f6e732f666f726b6d655f72696768745f6461726b626c75655f3132313632312e706e67" alt="Fork me on GitHub" data-canonical-src="https://s3.amazonaws.com/github/ribbons/forkme_right_darkblue_121621.png"></a>

</head>

  <body>
    <header>
      <div>
		
			<div id="imglogo">
				<a href="/"><img src="/img/logo.png" alt="Suzf Blog" title="Suzf Blog"/></a>
			</div>
			
			<div id="textlogo">
				<h1 class="site-name"><a href="/" title="Suzf Blog">Suzf Blog</a></h1>
				<h2 class="blog-motto">Life is short, We need smile.</h2>
			</div>
			<div class="navbar"><a class="navbutton navmobile" href="#" title="Menu">
			</a></div>
			<nav class="animated">
				<ul>
					
						<li><a href="/">Home</a></li>
					
						<li><a href="/archives">Archives</a></li>
					
						<li><a href="/about">About</a></li>
					

                        <li><a href="http://blog.suzf.net/atom.xml">Rss</a></li>
                        <li><a title="Let's High!!!" href='javascript:(function() {
	function c() {
		var e = document.createElement("link");
		e.setAttribute("type", "text/css");
		e.setAttribute("rel", "stylesheet");
		e.setAttribute("href", f);
		e.setAttribute("class", l);
		document.body.appendChild(e)
	}
 
	function h() {
		var e = document.getElementsByClassName(l);
		for (var t = 0; t < e.length; t++) {
			document.body.removeChild(e[t])
		}
	}
 
	function p() {
		var e = document.createElement("div");
		e.setAttribute("class", a);
		document.body.appendChild(e);
		setTimeout(function() {
			document.body.removeChild(e)
		}, 100)
	}
 
	function d(e) {
		return {
			height : e.offsetHeight,
			width : e.offsetWidth
		}
	}
 
	function v(i) {
		var s = d(i);
		return s.height > e && s.height < n && s.width > t && s.width < r
	}
 
	function m(e) {
		var t = e;
		var n = 0;
		while (!!t) {
			n += t.offsetTop;
			t = t.offsetParent
		}
		return n
	}
 
	function g() {
		var e = document.documentElement;
		if (!!window.innerWidth) {
			return window.innerHeight
		} else if (e && !isNaN(e.clientHeight)) {
			return e.clientHeight
		}
		return 0
	}
 
	function y() {
		if (window.pageYOffset) {
			return window.pageYOffset
		}
		return Math.max(document.documentElement.scrollTop, document.body.scrollTop)
	}
 
	function E(e) {
		var t = m(e);
		return t >= w && t <= b + w
	}
 
	function S() {
		var e = document.createElement("audio");
		e.setAttribute("class", l);
		e.src = i;
		e.loop = false;
		e.addEventListener("canplay", function() {
			setTimeout(function() {
				x(k)
			}, 500);
			setTimeout(function() {
				N();
				p();
				for (var e = 0; e < O.length; e++) {
					T(O[e])
				}
			}, 15500)
		}, true);
		e.addEventListener("ended", function() {
			N();
			h()
		}, true);
		e.innerHTML = " <p>If you are reading this, it is because your browser does not support the audio element. We recommend that you get a new browser.</p> <p>";
		document.body.appendChild(e);
		e.play()
	}
 
	function x(e) {
		e.className += " " + s + " " + o
	}
 
	function T(e) {
		e.className += " " + s + " " + u[Math.floor(Math.random() * u.length)]
	}
 
	function N() {
		var e = document.getElementsByClassName(s);
		var t = new RegExp("\\b" + s + "\\b");
		for (var n = 0; n < e.length; ) {
			e[n].className = e[n].className.replace(t, "")
		}
	}
 
	var e = 30;
	var t = 30;
	var n = 350;
	var r = 350;
	var i = "//s3.amazonaws.com/moovweb-marketing/playground/harlem-shake.mp3";
	var s = "mw-harlem_shake_me";
	var o = "im_first";
	var u = ["im_drunk", "im_baked", "im_trippin", "im_blown"];
	var a = "mw-strobe_light";
	var f = "//s3.amazonaws.com/moovweb-marketing/playground/harlem-shake-style.css";
	var l = "mw_added_css";
	var b = g();
	var w = y();
	var C = document.getElementsByTagName("*");
	var k = null;
	for (var L = 0; L < C.length; L++) {
		var A = C[L];
		if (v(A)) {
			if (E(A)) {
				k = A;
				break
			}
		}
	}
	if (A === null) {
		console.warn("Could not find a node of the right size. Please try a different page.");
		return
	}
	c();
	S();
	var O = [];
	for (var L = 0; L < C.length; L++) {
		var A = C[L];
		if (v(A)) {
			O.push(A)
		}
	}
})()    '>High一下</a> </li>

                    <li>
					
					<form class="search" action="//google.com/search" method="get" accept-charset="utf-8">
						<label>Search</label>
						<input type="text" id="search" name="q" autocomplete="off" maxlength="20" placeholder="Search" />
						<input type="hidden" name="q" value="site:blog.suzf.net">
					</form>
					
					</li>
				</ul>
			</nav>			
</div>

    </header>
    <div id="container">
      <div id="main" class="post" itemscope itemprop="blogPost">
	<article itemprop="articleBody"> 
		<header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2016/04/06/Tcpdump_notes/" title="Tcpdump notes" itemprop="url">Tcpdump notes</a>
  </h1>
  <p class="article-author">By
    
      <a href="http://blog.suzf.net" title="Jeffrey Su">Jeffrey Su</a>
    </p>
  <p class="article-time">
    <time datetime="2016-04-06T09:16:32.000Z" itemprop="datePublished">2016-04-06</time>
    Updated:<time datetime="2016-04-29T12:43:02.000Z" itemprop="dateModified">2016-04-29</time>
    
  </p>
</header>
	<div class="article-content">
		
		
		<div id="toc" class="toc-article">
			<strong class="toc-title">Contents</strong>
		<ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#u7528_u9014"><span class="toc-number">1.</span> <span class="toc-text">用途</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#u6743_u9650_u8981_u6C42"><span class="toc-number">2.</span> <span class="toc-text">权限要求</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#u547D_u4EE4_u4F7F_u7528"><span class="toc-number">3.</span> <span class="toc-text">命令使用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#tcpdump_u7684_u7B80_u5355_u9009_u9879_u4ECB_u7ECD"><span class="toc-number">4.</span> <span class="toc-text">tcpdump的简单选项介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#tcpdump_u6761_u4EF6_u8868_u8FBE_u5F0F"><span class="toc-number">5.</span> <span class="toc-text">tcpdump条件表达式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#u4E3E_u4E2A_u6817_u5B50"><span class="toc-number">6.</span> <span class="toc-text">举个栗子</span></a></li></ol>
		</div>
		
		<p><strong>tcpdump</strong> 是一个运行在<a href="https://zh.wikipedia.org/wiki/%E5%91%BD%E4%BB%A4%E8%A1%8C" title="命令行" target="_blank" rel="external">命令行</a>下的<a href="https://zh.wikipedia.org/wiki/%E5%97%85%E6%8E%A2" title="嗅探" target="_blank" rel="external">嗅探</a>工具。它允许用户拦截和显示发送或收到过<a href="https://zh.wikipedia.org/wiki/%E7%BD%91%E7%BB%9C" title="网络" target="_blank" rel="external">网络</a>连接到该计算机的<a href="https://zh.wikipedia.org/wiki/TCP/IP" title="TCP/IP" target="_blank" rel="external">TCP/IP</a>和其他<a href="https://zh.wikipedia.org/wiki/%E6%95%B0%E6%8D%AE%E5%8C%85" title="数据包" target="_blank" rel="external">数据包</a>。tcpdump 是一个在<a href="https://zh.wikipedia.org/wiki/BSD%E8%AE%B8%E5%8F%AF%E8%AF%81" title="BSD许可证" target="_blank" rel="external">BSD许可证</a>下发布<sup id="cite_ref-2" class="reference"><a href="https://zh.wikipedia.org/wiki/Tcpdump#cite_note-2" target="_blank" rel="external">[2]</a></sup>的<a href="https://zh.wikipedia.org/wiki/%E8%87%AA%E7%94%B1%E8%BD%AF%E4%BB%B6" title="自由软件" target="_blank" rel="external">自由软件</a>。</p>
<p>tcpdump 适用于大多数的<a href="https://zh.wikipedia.org/wiki/%E7%B1%BBUnix%E7%B3%BB%E7%BB%9F" title="类Unix系统" target="_blank" rel="external">类Unix系统</a> <a href="https://zh.wikipedia.org/wiki/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F" title="操作系统" target="_blank" rel="external">操作系统</a>：包括<a href="https://zh.wikipedia.org/wiki/Linux" title="Linux" target="_blank" rel="external">Linux</a>、<a href="https://zh.wikipedia.org/wiki/Solaris" title="Solaris" target="_blank" rel="external">Solaris</a>、<a href="https://zh.wikipedia.org/wiki/BSD" title="BSD" target="_blank" rel="external">BSD</a>、<a href="https://zh.wikipedia.org/wiki/Mac_OS_X" title="Mac OS X" target="_blank" rel="external">Mac OS X</a>、<a href="https://zh.wikipedia.org/wiki/HP-UX" title="HP-UX" target="_blank" rel="external">HP-UX</a>和<a href="https://zh.wikipedia.org/wiki/AIX" title="AIX" target="_blank" rel="external">AIX</a> 等等。在这些系统中，tcpdump 需要使用<a href="https://zh.wikipedia.org/w/index.php?title=Libpcap&amp;action=edit&amp;redlink=1" title="Libpcap（页面不存在）" target="_blank" rel="external">libpcap</a>这个捕捉数据的<a href="https://zh.wikipedia.org/wiki/%E5%BA%93" title="库" target="_blank" rel="external">库</a>。其在<a href="https://zh.wikipedia.org/wiki/Microsoft_Windows" title="Microsoft Windows" target="_blank" rel="external">Windows</a>下的版本称为<a href="https://zh.wikipedia.org/w/index.php?title=WinDump&amp;action=edit&amp;redlink=1" title="WinDump（页面不存在）" target="_blank" rel="external">WinDump</a>；它需要<a href="https://zh.wikipedia.org/w/index.php?title=WinPcap&amp;action=edit&amp;redlink=1" title="WinPcap（页面不存在）" target="_blank" rel="external">WinPcap</a>驱动，相当于在<a href="https://zh.wikipedia.org/wiki/Linux" title="Linux" target="_blank" rel="external">Linux</a>平台下的<a href="https://zh.wikipedia.org/w/index.php?title=Libpcap&amp;action=edit&amp;redlink=1" title="Libpcap（页面不存在）" target="_blank" rel="external">libpcap</a>.</p>
<h2 id="u7528_u9014"><a href="#u7528_u9014" class="headerlink" title="用途"></a><span id=".E7.94.A8.E9.80.94" class="mw-headline">用途</span></h2><p>tcpdump能够分析网络行为，性能和应用产生或接收网络流量。它支持针对网络层、协议、主机、网络或端口的过滤，并提供and、or、not等逻辑语句来帮助你去掉无用的信息，从而使用户能够进一步找出问题的根源。<a id="more"></a></p>
<p>也可以使用 tcpdump 的实现特定目的，例如在<a href="https://zh.wikipedia.org/wiki/%E8%B7%AF%E7%94%B1%E5%99%A8" title="路由器" target="_blank" rel="external">路由器</a>和<a href="https://zh.wikipedia.org/wiki/%E7%BD%91%E5%85%B3" title="网关" target="_blank" rel="external">网关</a>之间拦截并显示其他用户或计算机通信。通过 tcpdump 分析非加密的流量，如<a href="https://zh.wikipedia.org/wiki/Telnet" title="Telnet" target="_blank" rel="external">Telnet</a>或<a href="https://zh.wikipedia.org/wiki/HTTP" title="HTTP" target="_blank" rel="external">HTTP</a>的数据包，查看登录的用户名、密码、网址、正在浏览的网站内容，或任何其他信息。因此系统中存在网络分析工具主要不是对本机安全的威胁，而是对网络上的其他计算机的安全存在威胁。<sup id="cite_ref-3" class="reference"><a href="https://zh.wikipedia.org/wiki/Tcpdump#cite_note-3" target="_blank" rel="external">[3]</a></sup></p>
<p>有很多用户喜欢使用<a href="https://zh.wikipedia.org/wiki/BPF" title="BPF" target="_blank" rel="external">柏克莱数据包过滤器</a>来限制 tcpdump 产生的数据包数量，这样BPF会只把“感兴趣”的数据包到上层软件，可以避免从<a href="https://zh.wikipedia.org/wiki/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F" title="操作系统" target="_blank" rel="external">操作系统</a> <a href="https://zh.wikipedia.org/wiki/%E5%86%85%E6%A0%B8" title="内核" target="_blank" rel="external">内核</a>向用户态复制其他数据包，降低抓包的<a href="https://zh.wikipedia.org/wiki/CPU" title="CPU" target="_blank" rel="external">CPU</a>的负担以及所需的缓冲区空间，从而减少丢包率。</p>
<h2 id="u6743_u9650_u8981_u6C42"><a href="#u6743_u9650_u8981_u6C42" class="headerlink" title="权限要求"></a><span id=".E6.9D.83.E9.99.90.E8.A6.81.E6.B1.82" class="mw-headline">权限要求</span></h2><p>一些<a href="https://zh.wikipedia.org/wiki/%E7%B1%BBUnix%E7%B3%BB%E7%BB%9F" title="类Unix系统" target="_blank" rel="external">类Unix</a><a href="https://zh.wikipedia.org/wiki/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F" title="操作系统" target="_blank" rel="external">操作系统</a>，用户有必须拥有<a href="https://zh.wikipedia.org/wiki/%E8%B6%85%E7%BA%A7%E7%94%A8%E6%88%B7" title="超级用户" target="_blank" rel="external">超级用户</a>权限方可使用 tcpdump，因为在这些系统需要使用<a href="https://zh.wikipedia.org/wiki/%E8%B6%85%E7%BA%A7%E7%94%A8%E6%88%B7" title="超级用户" target="_blank" rel="external">超级用户</a>权限将网络界面设置为<a href="https://zh.wikipedia.org/wiki/%E6%B7%B7%E6%9D%82%E6%A8%A1%E5%BC%8F" target="_blank" rel="external">混杂模式</a>。然而，可以通过使用 -Z 选项在完成嗅探之后站即下降到一个特定的非特权用户的权限。在某一些类Unix操作系统，数据包嗅探机制可以配置为允许非特权用户可以使用它，如果做到这一点，就不需要超级用户权限。</p>
<h2 id="u547D_u4EE4_u4F7F_u7528"><a href="#u547D_u4EE4_u4F7F_u7528" class="headerlink" title="命令使用"></a>命令使用</h2><p>tcpdump采用命令行方式，它的命令格式为：</p>
<pre class="lang:default decode:true">tcpdump  --help
tcpdump version 4.1-PRE-CVS_2015_07_23
libpcap version 1.4.0
Usage: tcpdump [-aAdDefhIJKlLnNOpqRStuUvxX] [ -B size ] [ -c count ]
        [ -C file_size ] [ -E algo:secret ] [ -F file ] [ -G seconds ]
        [ -i interface ] [ -j tstamptype ] [ -M secret ]
        [ -P in|out|inout ]
        [ -r file ] [ -s snaplen ] [ -T type ] [ -w file ]
        [ -W filecount ] [ -y datalinktype ] [ -z command ]
        [ -Z user ] [ expression ]
</pre>

<h2 id="tcpdump_u7684_u7B80_u5355_u9009_u9879_u4ECB_u7ECD"><a href="#tcpdump_u7684_u7B80_u5355_u9009_u9879_u4ECB_u7ECD" class="headerlink" title="tcpdump的简单选项介绍"></a>tcpdump的简单选项介绍</h2><p>-A  以ASCII码方式显示每一个数据包(不会显示数据包中链路层头部信息). 在抓取包含网页数据的数据包时, 可方便查看数据(nt: 即Handy for capturing web pages).</p>
<p>-c  count<br>tcpdump将在接受到count个数据包后退出.</p>
<p>-C  file-size (nt: 此选项用于配合-w file 选项使用)<br>该选项使得tcpdump 在把原始数据包直接保存到文件中之前, 检查此文件大小是否超过file-size. 如果超过了, 将关闭此文件,另创一个文件继续用于原始数据包的记录. 新创建的文件名与-w 选项指定的文件名一致, 但文件名后多了一个数字.该数字会从1开始随着新创建文件的增多而增加. file-size的单位是百万字节(nt: 这里指1,000,000个字节,并非1,048,576个字节, 后者是以1024字节为1k, 1024k字节为1M计算所得, 即1M=1024 ＊ 1024 ＝ 1,048,576)</p>
<p>-d  以容易阅读的形式,在标准输出上打印出编排过的包匹配码, 随后tcpdump停止.(nt | rt: human readable, 容易阅读的,通常是指以ascii码来打印一些信息. compiled, 编排过的. packet-matching code, 包匹配码,含义未知, 需补充)</p>
<p>-dd 以C语言的形式打印出包匹配码.</p>
<p>-ddd 以十进制数的形式打印出包匹配码(会在包匹配码之前有一个附加的’count’前缀).</p>
<p>-D  打印系统中所有tcpdump可以在其上进行抓包的网络接口. 每一个接口会打印出数字编号, 相应的接口名字, 以及可能的一个网络接口描述. 其中网络接口名字和数字编号可以用在tcpdump 的-i flag 选项(nt: 把名字或数字代替flag), 来指定要在其上抓包的网络接口.</p>
<p>此选项在不支持接口列表命令的系统上很有用(nt: 比如, Windows 系统, 或缺乏 ifconfig -a 的UNIX系统); 接口的数字编号在windows 2000 或其后的系统中很有用, 因为这些系统上的接口名字比较复杂, 而不易使用.</p>
<p>如果tcpdump编译时所依赖的libpcap库太老,-D 选项不会被支持, 因为其中缺乏 pcap_findalldevs()函数.</p>
<p>-e  每行的打印输出中将包括数据包的数据链路层头部信息</p>
<p>-E  spi@ipaddr algo:secret,…</p>
<p>可通过spi@ipaddr algo:secret 来解密IPsec ESP包(nt | rt:IPsec Encapsulating Security Payload,IPsec 封装安全负载, IPsec可理解为, 一整套对ip数据包的加密协议, ESP 为整个IP 数据包或其中上层协议部分被加密后的数据,前者的工作模式称为隧道模式; 后者的工作模式称为传输模式 . 工作原理, 另需补充).</p>
<p>需要注意的是, 在终端启动tcpdump 时, 可以为IPv4 ESP packets 设置密钥(secret）.</p>
<p>可用于加密的算法包括des-cbc, 3des-cbc, blowfish-cbc, rc3-cbc, cast128-cbc, 或者没有(none).默认的是des-cbc(nt: des, Data Encryption Standard, 数据加密标准, 加密算法未知, 另需补充).secret 为用于ESP 的密钥, 使用ASCII 字符串方式表达. 如果以 0x 开头, 该密钥将以16进制方式读入.</p>
<p>该选项中ESP 的定义遵循RFC2406, 而不是 RFC1827. 并且, 此选项只是用来调试的, 不推荐以真实密钥(secret)来使用该选项, 因为这样不安全: 在命令行中输入的secret 可以被其他人通过ps 等命令查看到.</p>
<p>除了以上的语法格式(nt: 指spi@ipaddr algo:secret), 还可以在后面添加一个语法输入文件名字供tcpdump 使用(nt：即把spi@ipaddr algo:secret,… 中…换成一个语法文件名). 此文件在接受到第一个ESP　包时会打开此文件, 所以最好此时把赋予tcpdump 的一些特权取消(nt: 可理解为, 这样防范之后, 当该文件为恶意编写时,不至于造成过大损害).</p>
<p>-f  显示外部的IPv4 地址时(nt: foreign IPv4 addresses, 可理解为, 非本机ip地址), 采用数字方式而不是名字.(此选项是用来对付Sun公司的NIS服务器的缺陷(nt: NIS, 网络信息服务, tcpdump 显示外部地址的名字时会用到她提供的名称服务): 此NIS服务器在查询非本地地址名字时,常常会陷入无尽的查询循环).</p>
<p>由于对外部(foreign)IPv4地址的测试需要用到本地网络接口(nt: tcpdump 抓包时用到的接口)及其IPv4 地址和网络掩码. 如果此地址或网络掩码不可用, 或者此接口根本就没有设置相应网络地址和网络掩码(nt: linux 下的 ‘any’ 网络接口就不需要设置地址和掩码, 不过此’any’接口可以收到系统中所有接口的数据包), 该选项不能正常工作.</p>
<p>-F  file<br>使用file 文件作为过滤条件表达式的输入, 此时命令行上的输入将被忽略.</p>
<p>-i  interface</p>
<p>指定tcpdump 需要监听的接口.  如果没有指定, tcpdump 会从系统接口列表中搜寻编号最小的已配置好的接口(不包括 loopback 接口).一但找到第一个符合条件的接口, 搜寻马上结束.</p>
<p>在采用2.2版本或之后版本内核的Linux 操作系统上, ‘any’ 这个虚拟网络接口可被用来接收所有网络接口上的数据包(nt: 这会包括目的是该网络接口的, 也包括目的不是该网络接口的). 需要注意的是如果真实网络接口不能工作在’混杂’模式(promiscuous)下,则无法在’any’这个虚拟的网络接口上抓取其数据包.</p>
<p>如果 -D 标志被指定, tcpdump会打印系统中的接口编号，而该编号就可用于此处的interface 参数.</p>
<p>-l  对标准输出进行行缓冲(nt: 使标准输出设备遇到一个换行符就马上把这行的内容打印出来).在需要同时观察抓包打印以及保存抓包记录的时候很有用. 比如, 可通过以下命令组合来达到此目的:<br><code>tcpdump  -l  |  tee dat&#39;&#39; 或者</code>tcpdump  -l   &gt; dat  &amp;  tail  -f  dat’’.(nt: 前者使用tee来把tcpdump 的输出同时放到文件dat和标准输出中, 而后者通过重定向操作’&gt;’, 把tcpdump的输出放到dat 文件中, 同时通过tail把dat文件中的内容放到标准输出中)</p>
<p>-L  列出指定网络接口所支持的数据链路层的类型后退出.(nt: 指定接口通过-i 来指定)</p>
<p>-m  module<br>通过module 指定的file 装载SMI MIB 模块(nt: SMI，Structure of Management Information, 管理信息结构MIB, Management Information Base, 管理信息库. 可理解为, 这两者用于SNMP(Simple Network Management Protoco)协议数据包的抓取. 具体SNMP 的工作原理未知, 另需补充).</p>
<p>此选项可多次使用, 从而为tcpdump 装载不同的MIB 模块.</p>
<p>-M  secret  如果TCP 数据包(TCP segments)有TCP-MD5选项(在RFC 2385有相关描述), 则为其摘要的验证指定一个公共的密钥secret.</p>
<p>-n  不对地址(比如, 主机地址, 端口号)进行数字表示到名字表示的转换.</p>
<p>-N  不打印出host 的域名部分. 比如, 如果设置了此选现, tcpdump 将会打印’nic’ 而不是 ‘nic.ddn.mil’.</p>
<p>-O  不启用进行包匹配时所用的优化代码. 当怀疑某些bug是由优化代码引起的, 此选项将很有用.</p>
<p>-p  一般情况下, 把网络接口设置为非’混杂’模式. 但必须注意 , 在特殊情况下此网络接口还是会以’混杂’模式来工作； 从而, ‘-p’ 的设与不设, 不能当做以下选现的代名词:’ether host {local-hw-add}’ 或  ‘ether broadcast’(nt: 前者表示只匹配以太网地址为host 的包, 后者表示匹配以太网地址为广播地址的数据包).</p>
<p>-q  快速(也许用’安静’更好?)打印输出. 即打印很少的协议相关信息, 从而输出行都比较简短.</p>
<p>-R  设定tcpdump 对 ESP/AH 数据包的解析按照 RFC1825而不是RFC1829(nt: AH, 认证头, ESP， 安全负载封装, 这两者会用在IP包的安全传输机制中). 如果此选项被设置, tcpdump 将不会打印出’禁止中继’域(nt: relay prevention field). 另外,由于ESP/AH规范中没有规定ESP/AH数据包必须拥有协议版本号域,所以tcpdump不能从收到的ESP/AH数据包中推导出协议版本号.</p>
<p>-r  file<br>从文件file 中读取包数据. 如果file 字段为 ‘-‘ 符号, 则tcpdump 会从标准输入中读取包数据.</p>
<p>-S  打印TCP 数据包的顺序号时, 使用绝对的顺序号, 而不是相对的顺序号.(nt: 相对顺序号可理解为, 相对第一个TCP 包顺序号的差距,比如, 接受方收到第一个数据包的绝对顺序号为232323, 对于后来接收到的第2个,第3个数据包, tcpdump会打印其序列号为1, 2分别表示与第一个数据包的差距为1 和 2. 而如果此时-S 选项被设置, 对于后来接收到的第2个, 第3个数据包会打印出其绝对顺序号:232324, 232325).</p>
<p>-s  snaplen<br>设置tcpdump的数据包抓取长度为snaplen, 如果不设置默认将会是68字节(而支持网络接口分接头(nt: NIT, 上文已有描述,可搜索’网络接口分接头’关键字找到那里)的SunOS系列操作系统中默认的也是最小值是96).68字节对于IP, ICMP(nt: Internet Control Message Protocol,因特网控制报文协议), TCP 以及 UDP 协议的报文已足够, 但对于名称服务(nt: 可理解为dns, nis等服务), NFS服务相关的数据包会产生包截短. 如果产生包截短这种情况, tcpdump的相应打印输出行中会出现’’[|proto]’’的标志（proto 实际会显示为被截短的数据包的相关协议层次). 需要注意的是, 采用长的抓取长度(nt: snaplen比较大), 会增加包的处理时间, 并且会减少tcpdump 可缓存的数据包的数量， 从而会导致数据包的丢失. 所以, 在能抓取我们想要的包的前提下, 抓取长度越小越好.把snaplen 设置为0 意味着让tcpdump自动选择合适的长度来抓取数据包.</p>
<p>-T  type<br>强制tcpdump按type指定的协议所描述的包结构来分析收到的数据包.  目前已知的type 可取的协议为:<br>aodv (Ad-hoc On-demand Distance Vector protocol, 按需距离向量路由协议, 在Ad hoc(点对点模式)网络中使用),<br>cnfp (Cisco  NetFlow  protocol),  rpc(Remote Procedure Call), rtp (Real-Time Applications protocol),<br>rtcp (Real-Time Applications con-trol protocol), snmp (Simple Network Management Protocol),<br>tftp (Trivial File Transfer Protocol, 碎文件协议), vat (Visual Audio Tool, 可用于在internet 上进行电<br>视电话会议的应用层协议), 以及wb (distributed White Board, 可用于网络会议的应用层协议).</p>
<p>-t     在每行输出中不打印时间戳</p>
<p>-tt    不对每行输出的时间进行格式处理(nt: 这种格式一眼可能看不出其含义, 如时间戳打印成1261798315)</p>
<p>-ttt   tcpdump 输出时, 每两行打印之间会延迟一个段时间(以毫秒为单位)</p>
<p>-tttt  在每行打印的时间戳之前添加日期的打印</p>
<p>-u     打印出未加密的NFS 句柄(nt: handle可理解为NFS 中使用的文件句柄, 这将包括文件夹和文件夹中的文件)</p>
<p>-U    使得当tcpdump在使用-w 选项时, 其文件写入与包的保存同步.(nt: 即, 当每个数据包被保存时, 它将及时被写入文件中,而不是等文件的输出缓冲已满时才真正写入此文件)</p>
<p>-U 标志在老版本的libcap库(nt: tcpdump 所依赖的报文捕获库)上不起作用, 因为其中缺乏pcap_cump_flush()函数.</p>
<p>-v    当分析和打印的时候, 产生详细的输出. 比如, 包的生存时间, 标识, 总长度以及IP包的一些选项. 这也会打开一些附加的包完整性检测, 比如对IP或ICMP包头部的校验和.</p>
<p>-vv   产生比-v更详细的输出. 比如, NFS回应包中的附加域将会被打印, SMB数据包也会被完全解码.</p>
<p>-vvv  产生比-vv更详细的输出. 比如, telent 时所使用的SB, SE 选项将会被打印, 如果telnet同时使用的是图形界面,<br>其相应的图形选项将会以16进制的方式打印出来(nt: telnet 的SB,SE选项含义未知, 另需补充).</p>
<p>-w    把包数据直接写入文件而不进行分析和打印输出. 这些包数据可在随后通过-r 选项来重新读入并进行分析和打印.</p>
<p>-W    filecount<br>此选项与-C 选项配合使用, 这将限制可打开的文件数目, 并且当文件数据超过这里设置的限制时, 依次循环替代之前的文件, 这相当于一个拥有filecount 个文件的文件缓冲池. 同时, 该选项会使得每个文件名的开头会出现足够多并用来占位的0, 这可以方便这些文件被正确的排序.</p>
<p>-x    当分析和打印时, tcpdump 会打印每个包的头部数据, 同时会以16进制打印出每个包的数据(但不包括连接层的头部).总共打印的数据大小不会超过整个数据包的大小与snaplen 中的最小值. 必须要注意的是, 如果高层协议数据没有snaplen 这么长,并且数据链路层(比如, Ethernet层)有填充数据, 则这些填充数据也会被打印.(nt: so for link  layers  that pad, 未能衔接理解和翻译, 需补充 )</p>
<p>-xx   tcpdump 会打印每个包的头部数据, 同时会以16进制打印出每个包的数据, 其中包括数据链路层的头部.</p>
<p>-X    当分析和打印时, tcpdump 会打印每个包的头部数据, 同时会以16进制和ASCII码形式打印出每个包的数据(但不包括连接层的头部).这对于分析一些新协议的数据包很方便.</p>
<p>-XX   当分析和打印时, tcpdump 会打印每个包的头部数据, 同时会以16进制和ASCII码形式打印出每个包的数据, 其中包括数据链路层的头部.这对于分析一些新协议的数据包很方便.</p>
<p>-y    datalinktype<br>设置tcpdump 只捕获数据链路层协议类型是datalinktype的数据包</p>
<p>-Z    user<br>使tcpdump 放弃自己的超级权限(如果以root用户启动tcpdump, tcpdump将会有超级用户权限), 并把当前tcpdump的用户ID设置为user, 组ID设置为user首要所属组的ID(nt: tcpdump 此处可理解为tcpdump 运行之后对应的进程)</p>
<p>此选项也可在编译的时候被设置为默认打开.(nt: 此时user 的取值未知, 需补充)</p>
<h2 id="tcpdump_u6761_u4EF6_u8868_u8FBE_u5F0F"><a href="#tcpdump_u6761_u4EF6_u8868_u8FBE_u5F0F" class="headerlink" title="tcpdump条件表达式"></a>tcpdump条件表达式</h2><p>该表达式用于决定哪些数据包将被打印. 如果不给定条件表达式, 网络上所有被捕获的包都会被打印,否则, 只有满足条件表达式的数据包被打印.(nt: all packets, 可理解为, 所有被指定接口捕获的数据包).</p>
<p>表达式由一个或多个’表达元’组成(nt: primitive, 表达元, 可理解为组成表达式的基本元素). 一个表达元通常由一个或多个修饰符(qualifiers)后跟一个名字或数字表示的id组成(nt: 即, ‘qualifiers id’).有三种不同类型的修饰符:type, dir以及 proto.</p>
<p>type 修饰符指定id 所代表的对象类型, id可以是名字也可以是数字. 可选的对象类型有: host, net, port 以及portrange(nt: host 表明id表示主机, net 表明id是网络, port 表明id是端而portrange 表明id 是一个端口范围).  如, ‘host foo’, ‘net 128.3’, ‘port 20’, ‘portrange 6000-6008’(nt: 分别表示主机 foo,网络 128.3, 端口 20, 端口范围 6000-6008). 如果不指定type 修饰符, id默认的修饰符为host.</p>
<p>dir 修饰符描述id 所对应的传输方向, 即发往id 还是从id 接收（nt: 而id 到底指什么需要看其前面的type 修饰符）.可取的方向为: src, dst, src 或 dst, src并且dst.(nt:分别表示, id是传输源, id是传输目的, id是传输源或者传输目的, id是传输源并且是传输目的). 例如, ‘src foo’,’dst net 128.3’, ‘src or dst port ftp-data’.(nt: 分别表示符合条件的数据包中, 源主机是foo, 目的网络是128.3, 源或目的端口为 ftp-data).如果不指定dir修饰符, id 默认的修饰符为src 或 dst.对于链路层的协议,比如SLIP(nt: Serial Line InternetProtocol, 串联线路网际网络协议), 以及linux下指定’any’ 设备, 并指定’cooked’(nt | rt: cooked 含义未知, 需补充) 抓取类型, 或其他设备类型,可以用’inbound’ 和 ‘outbount’ 修饰符来指定想要的传输方向.</p>
<p>proto 修饰符描述id 所属的协议. 可选的协议有: ether, fddi, tr, wlan, ip, ip6, arp, rarp, decnet, tcp以及 upd.(nt | rt: ether, fddi, tr, 具体含义未知, 需补充. 可理解为物理以太网传输协议, 光纤分布数据网传输协议,以及用于路由跟踪的协议.  wlan, 无线局域网协议; ip,ip6 即通常的TCP/IP协议栈中所使用的ipv4以及ipv6网络层协议;arp, rarp 即地址解析协议,反向地址解析协议; decnet, Digital Equipment Corporation开发的, 最早用于PDP-11 机器互联的网络协议; tcp and udp, 即通常TCP/IP协议栈中的两个传输层协议).</p>
<p>例如, <code>ether src foo&#39;,</code>arp net 128.3’, <code>tcp port 21&#39;,</code>udp portrange 7000-7009’分别表示 ‘从以太网地址foo 来的数据包’,’发往或来自128.3网络的arp协议数据包’, ‘发送或接收端口为21的tcp协议数据包’, ‘发送或接收端口范围为7000-7009的udp协议数据包’.</p>
<p>如果不指定proto 修饰符, 则默认为与相应type匹配的修饰符. 例如, ‘src foo’ 含义是 ‘(ip or arp or rarp) src foo’ (nt: 即, 来自主机foo的ip/arp/rarp协议数据包, 默认type为host),<code>net bar&#39; 含义是</code>(ip  or  arp  or rarp) net bar’(nt: 即, 来自或发往bar网络的ip/arp/rarp协议数据包),<code>port 53&#39; 含义是</code>(tcp or udp) port 53’(nt: 即, 发送或接收端口为53的tcp/udp协议数据包).(nt: 由于tcpdump 直接通过数据链路层的 BSD 数据包过滤器或 DLPI(datalink provider interface, 数据链层提供者接口)来直接获得网络数据包, 其可抓取的数据包可涵盖上层的各种协议, 包括arp, rarp, icmp(因特网控制报文协议),ip, ip6, tcp, udp, sctp(流控制传输协议).</p>
<p>对于修饰符后跟id 的格式,可理解为, type id 是对包最基本的过滤条件: 即对包相关的主机, 网络, 端口的限制;dir 表示对包的传送方向的限制; proto表示对包相关的协议限制)</p>
<p>‘fddi’(nt: Fiber Distributed Data Interface) 实际上与’ether’ 含义一样: tcpdump 会把他们当作一种’’指定网络接口上的数据链路层协议’’. 如同ehter网(以太网), FDDI 的头部通常也会有源, 目的, 以及包类型, 从而可以像ether网数据包一样对这些域进行过滤. 此外, FDDI 头部还有其他的域, 但不能被放到表达式中用来过滤</p>
<p>同样, ‘tr’ 和 ‘wlan’ 也和 ‘ether’ 含义一致, 上一段对fddi 的描述同样适用于tr(Token Ring) 和wlan(802.11 wireless LAN)的头部. 对于802.11 协议数据包的头部, 目的域称为DA, 源域称为 SA;而其中的 BSSID, RA, TA 域(nt | rt: 具体含义需补充)不会被检测(nt: 不能被用于包过虑表达式中).</p>
<p>除以上所描述的表达元(‘primitive’)， 还有其他形式的表达元, 并且与上述表达元格式不同. 比如: gateway, broadcast, less, greater以及算术表达式(nt: 其中每一个都算一种新的表达元). 下面将会对这些表达元进行说明.</p>
<p>表达元之间还可以通过关键字and, or 以及 not 进行连接, 从而可组成比较复杂的条件表达式. 比如,`host foo and not port ftp and not port ftp-data’(nt: 其过滤条件可理解为, 数据包的主机为foo,并且端口不是ftp(端口21) 和ftp-data(端口20, 常用端口和名字的对应可在linux 系统中的/etc/service 文件中找到)).</p>
<p>为了表示方便, 同样的修饰符可以被省略, 如’tcp dst port ftp or ftp-data or domain’ 与以下的表达式含义相同’tcp dst port ftp or tcp dst port ftp-data or tcp dst port domain’.(nt: 其过滤条件可理解为,包的协议为tcp, 目的端口为ftp 或 ftp-data 或 domain(端口53) ).</p>
<p>借助括号以及相应操作符,可把表达元组合在一起使用(由于括号是shell的特殊字符, 所以在shell脚本或终端中使用时必须对括号进行转义, 即’(‘ 与’)’需要分别表达成’(‘ 与 ‘)‘).</p>
<p>有效的操作符有:</p>
<p><div class="cnblogs_code"></div></p>
<p><pre class=""> 否定操作 (<code>!&#39; 或</code>not’)<br> 与操作(<code>&amp;amp;&amp;amp;&#39; 或</code>and’)<br> 或操作(<code>||&#39; 或</code>or’)</pre><br><br>否定操作符的优先级别最高. 与操作和或操作优先级别相同, 并且二者的结合顺序是从左到右. 要注意的是, 表达’与操作’时,</p>
<p>需要显式写出’and’操作符, 而不只是把前后表达元并列放置(nt: 二者中间的’and’ 操作符不可省略).</p>
<p>如果一个标识符前没有关键字, 则表达式的解析过程中最近用过的关键字(往往也是从左往右距离标识符最近的关键字)将被使用.比如,<br>not host vs and ace<br>是以下表达的精简:<br>not host vs and host ace<br>而不是not (host vs or ace).(nt: 前两者表示, 所需数据包不是来自或发往host vs, 而是来自或发往ace.而后者表示数据包只要不是来自或发往vs或ac都符合要求)</p>
<p>整个条件表达式可以被当作一个单独的字符串参数也可以被当作空格分割的多个参数传入tcpdump, 后者更方便些. 通常, 如果表达式中包含元字符(nt: 如正则表达式中的’*’, ‘.’以及shell中的’(‘等字符)， 最好还是使用单独字符串的方式传入. 这时,整个表达式需要被单引号括起来. 多参数的传入方式中, 所有参数最终还是被空格串联在一起, 作为一个字符串被解析.</p>
<p>&nbsp;</p>
<h2 id="u4E3E_u4E2A_u6817_u5B50"><a href="#u4E3E_u4E2A_u6817_u5B50" class="headerlink" title="举个栗子"></a>举个栗子</h2><p><strong>默认启动</strong></p>
<p><div class="cnblogs_code"></div></p>
<p><pre>tcpdump</pre><br><br>普通情况下，直接启动<span lang="EN-US">tcpdump</span>将监视第一个网络接口上所有流过的数据包。</p>
<p><strong>监视指定网络接口的数据包</strong></p>
<p><div class="cnblogs_code"></div></p>
<p><pre class="">tcpdump -i eth1</pre><br><br>如果不指定网卡，默认tcpdump只会监视第一个网络接口，一般是eth0，下面的例子都没有指定网络接口。</p>
<p><strong>设置tcpdump的数据包抓取长度为snaplen</strong></p>
<p>默认值抓取数据包的前96个字节， -c 指定 指定数据包的个数</p>
<p><pre class="lang:default decode:true">tcpdump -i eth0 -nnv -s 1500 -c 100</pre><br><strong>抓包数据写入到文件</strong></p>
<p><pre class="lang:default decode:true">tcpdump -i eth0 -nnv -s 1500 -w /file1.tcpdump</pre><br><strong>监视指定主机的数据包</strong></p>
<p>打印所有进出sundown的数据包.</p>
<p><div class="cnblogs_code"></div></p>
<p><pre class="">tcpdump host sundown</pre><br><br>也可以指定ip,例如截获所有<span lang="EN-US">210.27.48.1 </span>的主机收到的和发出的所有的数据包</p>
<p><div class="cnblogs_code"></div></p>
<p><pre>tcpdump host 210.27.48.1</pre><br><br>打印helios 与 hot 或者与 ace 之间通信的数据包</p>
<p><div class="cnblogs_code"></div></p>
<p><pre>tcpdump host helios and ( hot or ace )</pre><br><br>截获主机<span lang="EN-US">210.27.48.1 </span>和主机<span lang="EN-US">210.27.48.2 </span>或<span lang="EN-US">210.27.48.3</span>的通信</p>
<p><div class="cnblogs_code"></div></p>
<p><pre>tcpdump host 210.27.48.1 and \ (210.27.48.2 or 210.27.48.3 )</pre><br><br>打印ace与任何其他主机之间通信的IP 数据包, 但不包括与helios之间的数据包.</p>
<p><div class="cnblogs_code"></div></p>
<p><pre>tcpdump ip host ace and not helios</pre><br><br>如果想要获取主机<span lang="EN-US">210.27.48.1</span>除了和主机<span lang="EN-US">210.27.48.2</span>之外所有主机通信的<span lang="EN-US">ip</span>包，使用命令：</p>
<p><div class="cnblogs_code"></div></p>
<p><pre>tcpdump ip host 210.27.48.1 and ! 210.27.48.2</pre><br><br>截获主机<span lang="EN-US">hostname</span>发送的所有数据</p>
<p><div class="cnblogs_code"></div></p>
<p><pre>tcpdump -i eth0 src host hostname</pre><br><br>监视所有送到主机<span lang="EN-US">hostname</span>的数据包</p>
<p><div class="cnblogs_code"></div></p>
<p><pre class="">tcpdump -i eth0 dst host hostname</pre><br><br><strong>监视指定网络的数据包</strong></p>
<p><pre class="lang:default decode:true">tcpdump -i eth0 -nnv net 192.168.9.0/24</pre><br><strong>监视指定主机和端口的数据包</strong></p>
<p>如果想要获取主机<span lang="EN-US">210.27.48.1</span>接收或发出的<span lang="EN-US">telnet</span>包，使用如下命令</p>
<p><div class="cnblogs_code"></div></p>
<p><pre class="">tcpdump tcp port 23 and host 210.27.48.1</pre><br><br>对本机的<span lang="EN-US">udp 123 </span>端口进行监视<span lang="EN-US"> 123 </span>为<span lang="EN-US">ntp</span>的服务端口</p>
<p><div class="cnblogs_code"></div></p>
<p><pre class="">tcpdump udp port 123</pre><br><br><strong>监视指定网络的数据包</strong></p>
<p>打印本地主机与Berkeley网络上的主机之间的所有通信数据包(nt: ucb-ether, 此处可理解为’Berkeley网络’的网络地址,此表达式最原始的含义可表达为: 打印网络地址为ucb-ether的所有数据包)</p>
<p><div class="cnblogs_code"></div></p>
<p><pre>tcpdump net ucb-ether</pre><br><br>打印所有通过网关snup的ftp数据包(注意, 表达式被单引号括起来了, 这可以防止shell对其中的括号进行错误解析)</p>
<p><div class="cnblogs_code"></div></p>
<p><pre>tcpdump gateway snup and (port ftp or ftp-data)</pre><br><br>打印所有源地址或目标地址是本地主机的IP数据包</p>
<p>(如果本地网络通过网关连到了另一网络, 则另一网络并不能算作本地网络.(nt: 此句翻译曲折,需补充).localnet 实际使用时要真正替换成本地网络的名字)</p>
<p><div class="cnblogs_code"></div></p>
<p><pre>tcpdump ip and not net localnet</pre><br></p>
<p><pre class="lang:default decode:true">tcpdump -i eth0 -nnv net 192.168.9.0/24</pre><br><strong>监视指定协议的数据包</strong></p>
<p>打印TCP会话中的的开始和结束数据包, 并且数据包的源或目的不是本地网络上的主机.(nt: localnet, 实际使用时要真正替换成本地网络的名字))</p>
<p><pre class="lang:default decode:true">tcpdump tcp[tcpflags] &amp; (tcp-syn|tcp-fin) != 0 and not src and dst net localnet</pre><br>打印所有源或目的端口是80, 网络层协议为IPv4, 并且含有数据,而不是SYN,FIN以及ACK-only等不含数据的数据包.(ipv6的版本的表达式可做练习)</p>
<p><pre class="lang:default decode:true">tcpdump tcp port 80 and (((ip[2:2] - ((ip[0]&amp;0xf)&lt;&lt;2)) - ((tcp[12]&amp;0xf0)&gt;&gt;2)) != 0)</pre><br>(nt: 可理解为, ip[2:2]表示整个ip数据包的长度, (ip[0]&amp;0xf)&lt;&lt;2)表示ip数据包包头的长度(ip[0]&amp;0xf代表包中的IHL域, 而此域的单位为32bit, 要换算</p>
<p>成字节数需要乘以4,　即左移2.　(tcp[12]&amp;0xf0)&gt;&gt;4 表示tcp头的长度, 此域的单位也是32bit,　换算成比特数为 ((tcp[12]&amp;0xf0) &gt;&gt; 4)　&lt;&lt;　２,<br>即 ((tcp[12]&amp;0xf0)&gt;&gt;2).　((ip[2:2] - ((ip[0]&amp;0xf)&lt;&lt;2)) - ((tcp[12]&amp;0xf0)&gt;&gt;2)) != 0　表示: 整个ip数据包的长度减去ip头的长度,再减去<br>tcp头的长度不为0, 这就意味着, ip数据包中确实是有数据.对于ipv6版本只需考虑ipv6头中的’Payload Length’ 与 ‘tcp头的长度’的差值, 并且其中表达方式’ip[]’需换成’ip6[]’.)</p>
<p>打印长度超过576字节, 并且网关地址是snup的IP数据包</p>
<p><pre class="lang:default decode:true">tcpdump gateway snup and ip[2:2] &gt; 576</pre><br>打印所有IP层广播或多播的数据包， 但不是物理以太网层的广播或多播数据报</p>
<p><pre class="lang:default decode:true">tcpdump ether[0] &amp; 1 = 0 and ip[16] &gt;= 224</pre><br>打印除’echo request’或者’echo reply’类型以外的ICMP数据包( 比如,需要打印所有非ping 程序产生的数据包时可用到此表达式 .<br>(nt: ‘echo reuqest’ 与 ‘echo reply’ 这两种类型的ICMP数据包通常由ping程序产生))</p>
<p><pre class="lang:default decode:true">tcpdump icmp[icmptype] != icmp-echo and icmp[icmptype] != icmp-echoreply</pre><br>&nbsp;</p>
<p><strong>tcpdump 与 wireshark</strong></p>
<p>Wireshark(以前是ethereal)是Windows下非常简单易用的抓包工具。但在Linux下很难找到一个好用的图形化抓包工具。<br>还好有Tcpdump。我们可以用Tcpdump + Wireshark 的完美组合实现：在 Linux 里抓包，然后在Windows 里分析包。</p>
<p><div class="cnblogs_code"></div></p>
<p><pre class="">tcpdump tcp -i eth1 -t -s 0 -c 100 and dst port ! 22 and src net 192.168.1.0/24 -w ./target.pcap</pre><br><br>(1)tcp: ip icmp arp rarp 和 tcp、udp、icmp这些选项等都要放到第一个参数的位置，用来过滤数据报的类型<br>(2)-i eth1 : 只抓经过接口eth1的包<br>(3)-t : 不显示时间戳<br>(4)-s 0 : 抓取数据包时默认抓取长度为68字节。加上-S 0 后可以抓到完整的数据包<br>(5)-c 100 : 只抓取100个数据包<br>(6)dst port ! 22 : 不抓取目标端口是22的数据包<br>(7)src net 192.168.1.0/24 : 数据包的源网络地址为192.168.1.0/24<br>(8)-w ./target.pcap : 保存成pcap文件，方便用ethereal(即wireshark)分析</p>
<hr>
<p><strong>使用tcpdump抓取HTTP包</strong></p>
<p><pre class="lang:default decode:true">tcpdump  -XvvennSs 0 -i eth0 tcp[20:2]=0x4745 or tcp[20:2]=0x4854</pre><br>0x4745 为”GET”前两个字母”GE”,0x4854 为”HTTP”前两个字母”HT”。</p>
<p>tcpdump 对截获的数据并没有进行彻底解码，数据包内的大部分内容是使用十六进制的形式直接打印输出的。显然这不利于分析网络故障，通常的解决办法是先使用带-w参 数的tcpdump 截获数据并保存到文件中，然后再使用其他程序(如Wireshark)进行解码分析。当然也应该定义过滤规则，以避免捕获的数据包填满整个硬盘。</p>
<p>抓取 demo.suzf.net  80/443 端口数据</p>
<p><pre class="lang:default decode:true">tcpdump  -nnv -s 0 -i eth1 host demo.suzf.net and  ( port 80 or port 443) -w /tmp/portal.pcap</pre><br>&nbsp;</p>
<p>Reference：</p>
<p><a href="http://www.tcpdump.org/manpages/tcpdump.1.html" target="_blank" rel="external">Tcpdump man page</a><br><a href="https://zh.wikipedia.org/wiki/Tcpdump" target="_blank" rel="external">Tcpdump wiki</a><br><a href="http://www.cnblogs.com/ggjucheng/archive/2012/01/14/2322659.html" target="_blank" rel="external">Linux tcpdump命令详解</a></p>
  
	</div>
		<footer class="article-footer clearfix">

  <div class="article-tags">
  
  <span></span> <a href="/tags/tcpdump/">tcpdump</a>
  </div>


<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/Linux/">Linux</a>
</div>



<div class="article-share" id="share">

  <div data-url="http://blog.suzf.net/2016/04/06/Tcpdump_notes/" data-title="Tcpdump notes | Suzf Blog" data-tsina="null" class="share clearfix">
  </div>

</div>
</footer>   	       
	</article>
	
<nav class="article-nav clearfix">
 
 <div class="prev" >
 <a href="/2016/04/13/密码散列安全/" title="密码散列安全">
  <strong>PREVIOUS:</strong><br/>
  <span>
  密码散列安全</span>
</a>
</div>


<div class="next">
<a href="/2016/04/06/MySQL__特性分析__InnoDB_transaction_history/"  title="MySQL  特性分析  InnoDB transaction history">
 <strong>NEXT:</strong><br/> 
 <span>MySQL  特性分析  InnoDB transaction history
</span>
</a>
</div>

</nav>

	
<section class="comment">
	<div class="ds-thread"></div>
</section>

</div>  
      <div class="openaside"><a class="navbutton" href="#" title="Show Sidebar"></a></div>

  <div id="toc" class="toc-aside">
  <strong class="toc-title">Contents</strong>
  <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#u7528_u9014"><span class="toc-number">1.</span> <span class="toc-text">用途</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#u6743_u9650_u8981_u6C42"><span class="toc-number">2.</span> <span class="toc-text">权限要求</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#u547D_u4EE4_u4F7F_u7528"><span class="toc-number">3.</span> <span class="toc-text">命令使用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#tcpdump_u7684_u7B80_u5355_u9009_u9879_u4ECB_u7ECD"><span class="toc-number">4.</span> <span class="toc-text">tcpdump的简单选项介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#tcpdump_u6761_u4EF6_u8868_u8FBE_u5F0F"><span class="toc-number">5.</span> <span class="toc-text">tcpdump条件表达式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#u4E3E_u4E2A_u6817_u5B50"><span class="toc-number">6.</span> <span class="toc-text">举个栗子</span></a></li></ol>
  </div>

<div id="asidepart">
<div class="closeaside"><a class="closebutton" href="#" title="Hide Sidebar"></a></div>
<aside class="clearfix">

  
<div class="categorieslist">
	<p class="asidetitle">Categories</p>
		<ul>
		
			<li><a href="/categories/Apache/" title="Apache">Apache<sup>1</sup></a></li>
		
			<li><a href="/categories/Auto-ops/" title="Auto ops">Auto ops<sup>3</sup></a></li>
		
			<li><a href="/categories/CouchBase/" title="CouchBase">CouchBase<sup>1</sup></a></li>
		
			<li><a href="/categories/HA/" title="HA">HA<sup>1</sup></a></li>
		
			<li><a href="/categories/Hadoop/" title="Hadoop">Hadoop<sup>6</sup></a></li>
		
			<li><a href="/categories/Hardware/" title="Hardware">Hardware<sup>1</sup></a></li>
		
			<li><a href="/categories/Highcharts/" title="Highcharts">Highcharts<sup>1</sup></a></li>
		
			<li><a href="/categories/LVS/" title="LVS">LVS<sup>1</sup></a></li>
		
			<li><a href="/categories/Life/" title="Life">Life<sup>3</sup></a></li>
		
			<li><a href="/categories/Linux/" title="Linux">Linux<sup>28</sup></a></li>
		
			<li><a href="/categories/MongoDB/" title="MongoDB">MongoDB<sup>3</sup></a></li>
		
			<li><a href="/categories/Mysql/" title="Mysql">Mysql<sup>10</sup></a></li>
		
			<li><a href="/categories/Nginx/" title="Nginx">Nginx<sup>5</sup></a></li>
		
			<li><a href="/categories/Oracle/" title="Oracle">Oracle<sup>2</sup></a></li>
		
			<li><a href="/categories/PHP/" title="PHP">PHP<sup>1</sup></a></li>
		
			<li><a href="/categories/Puppet/" title="Puppet">Puppet<sup>6</sup></a></li>
		
			<li><a href="/categories/Python/" title="Python">Python<sup>23</sup></a></li>
		
			<li><a href="/categories/Redis/" title="Redis">Redis<sup>7</sup></a></li>
		
			<li><a href="/categories/Shell/" title="Shell">Shell<sup>2</sup></a></li>
		
			<li><a href="/categories/Tomcat/" title="Tomcat">Tomcat<sup>1</sup></a></li>
		
			<li><a href="/categories/Web/" title="Web">Web<sup>5</sup></a></li>
		
			<li><a href="/categories/Zabbix/" title="Zabbix">Zabbix<sup>13</sup></a></li>
		
		</ul>
</div>


  
<div class="tagslist">
	<p class="asidetitle">Tags</p>
		<ul class="clearfix">
		
			<li><a href="/tags/Apache/" title="Apache">Apache<sup>1</sup></a></li>
		
			<li><a href="/tags/CMD/" title="CMD">CMD<sup>1</sup></a></li>
		
			<li><a href="/tags/Ceph/" title="Ceph">Ceph<sup>2</sup></a></li>
		
			<li><a href="/tags/Debian/" title="Debian">Debian<sup>1</sup></a></li>
		
			<li><a href="/tags/ELK/" title="ELK">ELK<sup>1</sup></a></li>
		
			<li><a href="/tags/Exsi/" title="Exsi">Exsi<sup>1</sup></a></li>
		
			<li><a href="/tags/Flask/" title="Flask">Flask<sup>1</sup></a></li>
		
			<li><a href="/tags/GTID/" title="GTID">GTID<sup>2</sup></a></li>
		
			<li><a href="/tags/Kernel/" title="Kernel">Kernel<sup>2</sup></a></li>
		
			<li><a href="/tags/Kickstart/" title="Kickstart">Kickstart<sup>1</sup></a></li>
		
			<li><a href="/tags/LB/" title="LB">LB<sup>1</sup></a></li>
		
			<li><a href="/tags/LVS/" title="LVS">LVS<sup>1</sup></a></li>
		
			<li><a href="/tags/Life/" title="Life">Life<sup>1</sup></a></li>
		
			<li><a href="/tags/Linux/" title="Linux">Linux<sup>1</sup></a></li>
		
			<li><a href="/tags/Lnmp/" title="Lnmp">Lnmp<sup>1</sup></a></li>
		
			<li><a href="/tags/Log/" title="Log">Log<sup>1</sup></a></li>
		
			<li><a href="/tags/MongoDB/" title="MongoDB">MongoDB<sup>3</sup></a></li>
		
			<li><a href="/tags/Mysql/" title="Mysql">Mysql<sup>15</sup></a></li>
		
			<li><a href="/tags/Nginx/" title="Nginx">Nginx<sup>8</sup></a></li>
		
			<li><a href="/tags/NoSQL/" title="NoSQL">NoSQL<sup>4</sup></a></li>
		
		</ul>
</div>


</aside>
</div>
    </div>
    <footer><div id="footer" >
	
	<div class="line">
		<span></span>
		<div class="author"></div>
	</div>
	
	
	<section class="info">
		<p> Hello, I&#39;m a linuser. <br/>
			This is my blog, share with you. ^_^</p>
	</section>
	 
	<div class="social-font clearfix">
		
		
		
		<a href="https://github.com/oceanszf" target="_blank" title="github"></a>
		
		
		
	</div>
    <p class="copyright">Copyright © 2016 <a href="http://suzf.net" target="_blank" title="SUZF.NET">SUZF.NET</a> All Rights Reserved.
<!--		
		<a href="http://blog.suzf.net" target="_blank" title="Jeffrey Su">Jeffrey Su</a>
		
        -->
		</p>
</div>
</footer>
    <script src="/js/jquery-2.1.0.min.js"></script>
<script type="text/javascript">
$(document).ready(function(){ 
  $('.navbar').click(function(){
    $('header nav').toggleClass('shownav');
  });
  var myWidth = 0;
  function getSize(){
    if( typeof( window.innerWidth ) == 'number' ) {
      myWidth = window.innerWidth;
    } else if( document.documentElement && document.documentElement.clientWidth) {
      myWidth = document.documentElement.clientWidth;
    };
  };
  var m = $('#main'),
      a = $('#asidepart'),
      c = $('.closeaside'),
      o = $('.openaside');
  $(window).resize(function(){
    getSize(); 
    if (myWidth >= 1024) {
      $('header nav').removeClass('shownav');
    }else
    {
      m.removeClass('moveMain');
      a.css('display', 'block').removeClass('fadeOut');
      o.css('display', 'none');
      
      $('#toc.toc-aside').css('display', 'none');
        
    }
  });
  c.click(function(){
    a.addClass('fadeOut').css('display', 'none');
    o.css('display', 'block').addClass('fadeIn');
    m.addClass('moveMain');
  });
  o.click(function(){
    o.css('display', 'none').removeClass('beforeFadeIn');
    a.css('display', 'block').removeClass('fadeOut').addClass('fadeIn');      
    m.removeClass('moveMain');
  });
  $(window).scroll(function(){
    o.css("top",Math.max(80,260-$(this).scrollTop()));
  });
});
</script>

<script type="text/javascript">
$(document).ready(function(){ 
  var ai = $('.article-content>iframe'),
      ae = $('.article-content>embed'),
      t  = $('#toc'),
      h  = $('article h2')
      ah = $('article h2'),
      ta = $('#toc.toc-aside'),
      o  = $('.openaside'),
      c  = $('.closeaside');
  if(ai.length>0){
    ai.wrap('<div class="video-container" />');
  };
  if(ae.length>0){
   ae.wrap('<div class="video-container" />');
  };
  if(ah.length==0){
    t.css('display','none');
  }else{
    c.click(function(){
      ta.css('display', 'block').addClass('fadeIn');
    });
    o.click(function(){
      ta.css('display', 'none');
    });
    $(window).scroll(function(){
      ta.css("top",Math.max(140,320-$(this).scrollTop()));
    });
  };
});
</script>


<script type="text/javascript">
$(document).ready(function(){ 
  var $this = $('.share'),
      url = $this.attr('data-url'),
      encodedUrl = encodeURIComponent(url),
      title = $this.attr('data-title'),
      tsina = $this.attr('data-tsina');
  var html = [
  '<a href="#" class="overlay" id="qrcode"></a>',
  '<div class="qrcode clearfix"><span>扫描二维码分享到微信朋友圈</span><a class="qrclose" href="#share"></a><strong>Loading...Please wait</strong><img id="qrcode-pic" data-src="http://s.jiathis.com/qrcode.php?url=' + encodedUrl + '"/></div>',
  '<a href="#textlogo" class="article-back-to-top" title="Top"></a>',
  '<a href="https://www.facebook.com/sharer.php?u=' + encodedUrl + '" class="article-share-facebook" target="_blank" title="Facebook"></a>',
  '<a href="#qrcode" class="article-share-qrcode" title="QRcode"></a>',
  '<a href="https://twitter.com/intent/tweet?url=' + encodedUrl + '" class="article-share-twitter" target="_blank" title="Twitter"></a>',
  '<a href="http://service.weibo.com/share/share.php?title='+title+'&url='+encodedUrl +'&ralateUid='+ tsina +'&searchPic=true&style=number' +'" class="article-share-weibo" target="_blank" title="Weibo"></a>',
  '<span title="Share to"></span>'
  ].join('');
  $this.append(html);
  $('.article-share-qrcode').click(function(){
    var imgSrc = $('#qrcode-pic').attr('data-src');
    $('#qrcode-pic').attr('src', imgSrc);
    $('#qrcode-pic').load(function(){
        $('.qrcode strong').text(' ');
    });
  });
});     
</script>


<script type="text/javascript">
  var duoshuoQuery = {short_name:"Comment"};
  (function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0] 
    || document.getElementsByTagName('body')[0]).appendChild(ds);
  })();
</script> 





  </body>
</html>


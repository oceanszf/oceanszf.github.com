
 <!DOCTYPE HTML>
<html lang="default">
<head>
  <meta charset="UTF-8">
  
    <title>Python正则表达式操作指南 | Suzf Blog</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=3, minimum-scale=1">
    
    <meta name="author" content="Jeffrey Su">
    
    <meta name="description" content="摘要本文是通过Python的 re 模块来使用正则表达式的一个入门教程，和库参考手册的对应章节相比，更为浅显易懂、循序渐进。
简介 Python 自1.5版本起增加了re 模块，它提供 Perl 风格的正则表达式模式。Python 1.5之前版本则是通过 regex 模块提供 Emacs 风格的模式。Emacs 风格模式可读性稍差些，而且功能也不强，因此编写新代码时尽量不要再使用 regex 模块，当然偶尔你还是可能在老代码里发现其踪影。就其本质而言，正则表达式（或 RE）是一种小型的、高度专业化的编程语言，（在Python中）它内嵌在Python中，并通过 re 模块实现。使用这个小型语言，你可以为想要匹配的相应字符串集指定规则；该字符串集可能包含英文语句、e-mail地址、TeX命令或任何你想搞定的东 西。然后你可以问诸如“这个字符串匹配该模式吗？”或“在这个字符串中是否有部分匹配该模式呢？”。你也可以使用 RE 以各种方式来修改或分割字符串。正则表达式模式被编译成一系列的字节码，然后由用 C 编写的匹配引擎执行。在高级用法中，也许还要仔细留意引擎是如何执行给定 RE ，如何以特定方式编写 RE 以令生产的字节码运行速度更快。本文并不涉及优化，因为那要求你已充分掌握了匹配引擎的内部机制。正则表达式语言相对小型和受限（功能有限），因此并非所有字符串处理都能用正则表达式完成。当然也有些任务可以用正则表达式完成，不过最终表达式会变得异 常复杂。碰到这些情形时，编写 Python 代码进行处理可能反而更好；尽管 Python 代码比一个精巧的正则表达式要慢些，但它更易理解。
&amp;nbsp;
简单模式 我们将从最简单的正则表达式学习开始。由于正则表达式常用于字符串操作，那我们就从最常见的任务：字符匹配 下手。有关正则表达式底层的计算机科学上的详细解释（确定性和非确定性有限自动机），你可以查阅编写编译器相关的任何教科书。
&amp;nbsp;
 字符匹配 大多数字母和字符一般都会和自身匹配。例如，正则表达式 test 会和字符串“test”完全匹配。（你也可以使用大小写不敏感模式，它还能让这个 RE 匹配“Test”或“TEST”；稍后会有更多解释。）
这个规则当然会有例外；有些字符比较特殊，它们和自身并不匹配，而是会表明应和一些特殊的东西匹配，或者它们会影响到 RE 其它部分的重复次数。本文很大篇幅专门讨论了各种元字符及其作用。
这里有一个元字符的完整列表；其含义会在本指南余下部分进行讨论。">
    
    
    
    
    <link rel="alternate" href="/atom.xml" title="Suzf Blog" type="application/atom+xml">
    
    
    <link rel="stylesheet" href="/css/style.css" type="text/css">
    
    <link rel="icon" href="/img/favicon.ico">
    <a href="https://github.com/oceanszf" target="_blank"><img style="position: absolute; top: 0; right: 0; border: 0;" src="https://camo.githubusercontent.com/38ef81f8aca64bb9a64448d0d70f1308ef5341ab/68747470733a2f2f73332e616d617a6f6e6177732e636f6d2f6769746875622f726962626f6e732f666f726b6d655f72696768745f6461726b626c75655f3132313632312e706e67" alt="Fork me on GitHub" data-canonical-src="https://s3.amazonaws.com/github/ribbons/forkme_right_darkblue_121621.png"></a>

</head>

  <body>
    <header>
      <div>
		
			<div id="imglogo">
				<a href="/"><img src="/img/logo.png" alt="Suzf Blog" title="Suzf Blog"/></a>
			</div>
			
			<div id="textlogo">
				<h1 class="site-name"><a href="/" title="Suzf Blog">Suzf Blog</a></h1>
				<h2 class="blog-motto">Life is short, We need smile.</h2>
			</div>
			<div class="navbar"><a class="navbutton navmobile" href="#" title="Menu">
			</a></div>
			<nav class="animated">
				<ul>
					
						<li><a href="/">Home</a></li>
					
						<li><a href="/archives">Archives</a></li>
					
						<li><a href="/about">About</a></li>
					

                        <li><a href="http://blog.suzf.net/atom.xml">Rss</a></li>
                        <li><a title="Let's High!!!" href='javascript:(function() {
	function c() {
		var e = document.createElement("link");
		e.setAttribute("type", "text/css");
		e.setAttribute("rel", "stylesheet");
		e.setAttribute("href", f);
		e.setAttribute("class", l);
		document.body.appendChild(e)
	}
 
	function h() {
		var e = document.getElementsByClassName(l);
		for (var t = 0; t < e.length; t++) {
			document.body.removeChild(e[t])
		}
	}
 
	function p() {
		var e = document.createElement("div");
		e.setAttribute("class", a);
		document.body.appendChild(e);
		setTimeout(function() {
			document.body.removeChild(e)
		}, 100)
	}
 
	function d(e) {
		return {
			height : e.offsetHeight,
			width : e.offsetWidth
		}
	}
 
	function v(i) {
		var s = d(i);
		return s.height > e && s.height < n && s.width > t && s.width < r
	}
 
	function m(e) {
		var t = e;
		var n = 0;
		while (!!t) {
			n += t.offsetTop;
			t = t.offsetParent
		}
		return n
	}
 
	function g() {
		var e = document.documentElement;
		if (!!window.innerWidth) {
			return window.innerHeight
		} else if (e && !isNaN(e.clientHeight)) {
			return e.clientHeight
		}
		return 0
	}
 
	function y() {
		if (window.pageYOffset) {
			return window.pageYOffset
		}
		return Math.max(document.documentElement.scrollTop, document.body.scrollTop)
	}
 
	function E(e) {
		var t = m(e);
		return t >= w && t <= b + w
	}
 
	function S() {
		var e = document.createElement("audio");
		e.setAttribute("class", l);
		e.src = i;
		e.loop = false;
		e.addEventListener("canplay", function() {
			setTimeout(function() {
				x(k)
			}, 500);
			setTimeout(function() {
				N();
				p();
				for (var e = 0; e < O.length; e++) {
					T(O[e])
				}
			}, 15500)
		}, true);
		e.addEventListener("ended", function() {
			N();
			h()
		}, true);
		e.innerHTML = " <p>If you are reading this, it is because your browser does not support the audio element. We recommend that you get a new browser.</p> <p>";
		document.body.appendChild(e);
		e.play()
	}
 
	function x(e) {
		e.className += " " + s + " " + o
	}
 
	function T(e) {
		e.className += " " + s + " " + u[Math.floor(Math.random() * u.length)]
	}
 
	function N() {
		var e = document.getElementsByClassName(s);
		var t = new RegExp("\\b" + s + "\\b");
		for (var n = 0; n < e.length; ) {
			e[n].className = e[n].className.replace(t, "")
		}
	}
 
	var e = 30;
	var t = 30;
	var n = 350;
	var r = 350;
	var i = "//s3.amazonaws.com/moovweb-marketing/playground/harlem-shake.mp3";
	var s = "mw-harlem_shake_me";
	var o = "im_first";
	var u = ["im_drunk", "im_baked", "im_trippin", "im_blown"];
	var a = "mw-strobe_light";
	var f = "//s3.amazonaws.com/moovweb-marketing/playground/harlem-shake-style.css";
	var l = "mw_added_css";
	var b = g();
	var w = y();
	var C = document.getElementsByTagName("*");
	var k = null;
	for (var L = 0; L < C.length; L++) {
		var A = C[L];
		if (v(A)) {
			if (E(A)) {
				k = A;
				break
			}
		}
	}
	if (A === null) {
		console.warn("Could not find a node of the right size. Please try a different page.");
		return
	}
	c();
	S();
	var O = [];
	for (var L = 0; L < C.length; L++) {
		var A = C[L];
		if (v(A)) {
			O.push(A)
		}
	}
})()    '>High一下</a> </li>

                    <li>
					
					<form class="search" action="//google.com/search" method="get" accept-charset="utf-8">
						<label>Search</label>
						<input type="text" id="search" name="q" autocomplete="off" maxlength="20" placeholder="Search" />
						<input type="hidden" name="q" value="site:blog.suzf.net">
					</form>
					
					</li>
				</ul>
			</nav>			
</div>

    </header>
    <div id="container">
      <div id="main" class="post" itemscope itemprop="blogPost">
	<article itemprop="articleBody"> 
		<header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2016/04/22/Python正则表达式操作指南/" title="Python正则表达式操作指南" itemprop="url">Python正则表达式操作指南</a>
  </h1>
  <p class="article-author">By
    
      <a href="http://blog.suzf.net" title="Jeffrey Su">Jeffrey Su</a>
    </p>
  <p class="article-time">
    <time datetime="2016-04-22T04:53:10.000Z" itemprop="datePublished">2016-04-22</time>
    Updated:<time datetime="2016-04-29T12:43:02.000Z" itemprop="dateModified">2016-04-29</time>
    
  </p>
</header>
	<div class="article-content">
		
		
		<div id="toc" class="toc-article">
			<strong class="toc-title">Contents</strong>
		<ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#u7B80_u4ECB"><span class="toc-number">1.</span> <span class="toc-text">简介 </span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#u7B80_u5355_u6A21_u5F0F"><span class="toc-number">2.</span> <span class="toc-text">简单模式 </span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#u5B57_u7B26_u5339_u914D"><span class="toc-number">2.1.</span> <span class="toc-text"> 字符匹配 </span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#u6A21_u5757_u7EA7_u51FD_u6570"><span class="toc-number">2.2.</span> <span class="toc-text">模块级函数 </span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#u7F16_u8BD1_u6807_u5FD7"><span class="toc-number">2.3.</span> <span class="toc-text">编译标志 </span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#u66F4_u591A_u6A21_u5F0F_u529F_u80FD"><span class="toc-number">3.</span> <span class="toc-text">更多模式功能 </span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#u66F4_u591A_u7684_u5143_u5B57_u7B26"><span class="toc-number">3.1.</span> <span class="toc-text">更多的元字符 </span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#u5206_u7EC4"><span class="toc-number">3.2.</span> <span class="toc-text">分组 </span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#u65E0_u6355_u83B7_u7EC4_u548C_u547D_u540D_u7EC4"><span class="toc-number">3.3.</span> <span class="toc-text">无捕获组和命名组 </span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#u524D_u5411_u754C_u5B9A_u7B26"><span class="toc-number">3.4.</span> <span class="toc-text">前向界定符 </span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#u4FEE_u6539_u5B57_u7B26_u4E32"><span class="toc-number">4.</span> <span class="toc-text">修改字符串 </span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#u5C06_u5B57_u7B26_u4E32_u5206_u7247"><span class="toc-number">4.1.</span> <span class="toc-text">将字符串分片 </span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#u641C_u7D22_u548C_u66FF_u6362"><span class="toc-number">4.2.</span> <span class="toc-text">搜索和替换 </span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#u5E38_u89C1_u95EE_u9898"><span class="toc-number">5.</span> <span class="toc-text">常见问题 </span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#u4F7F_u7528_u5B57_u7B26_u4E32_u65B9_u5F0F"><span class="toc-number">5.1.</span> <span class="toc-text">使用字符串方式 </span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#match_28_29_vs_search_28_29"><span class="toc-number">5.2.</span> <span class="toc-text">match() vs search() </span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#u8D2A_u5A6A_vs__u4E0D_u8D2A_u5A6A"><span class="toc-number">5.3.</span> <span class="toc-text">贪婪 vs 不贪婪 </span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#u4E0D_u7528_re-VERBOSE"><span class="toc-number">5.4.</span> <span class="toc-text">不用 re.VERBOSE</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#lose_the_following_trailing_whitespace"><span class="toc-number"></span> <span class="toc-text">lose the following trailing whitespace</span></a>
		</div>
		
		<p><strong> 摘要</strong><br>本文是通过Python的 re 模块来使用正则表达式的一个入门教程，和库参考手册的对应章节相比，更为浅显易懂、循序渐进。</p>
<h3 id="u7B80_u4ECB"><a href="#u7B80_u4ECB" class="headerlink" title="简介"></a><span class="mw-headline">简介 </span></h3><p>Python 自1.5版本起增加了re 模块，它提供 Perl 风格的正则表达式模式。Python 1.5之前版本则是通过 regex 模块提供 Emacs 风格的模式。Emacs 风格模式可读性稍差些，而且功能也不强，因此编写新代码时尽量不要再使用 regex 模块，当然偶尔你还是可能在老代码里发现其踪影。<br>就其本质而言，正则表达式（或 RE）是一种小型的、高度专业化的编程语言，（在Python中）它内嵌在Python中，并通过 re 模块实现。使用这个小型语言，你可以为想要匹配的相应字符串集指定规则；该字符串集可能包含英文语句、e-mail地址、TeX命令或任何你想搞定的东 西。然后你可以问诸如“这个字符串匹配该模式吗？”或“在这个字符串中是否有部分匹配该模式呢？”。你也可以使用 RE 以各种方式来修改或分割字符串。<br>正则表达式模式被编译成一系列的字节码，然后由用 C 编写的匹配引擎执行。在高级用法中，也许还要仔细留意引擎是如何执行给定 RE ，如何以特定方式编写 RE 以令生产的字节码运行速度更快。本文并不涉及优化，因为那要求你已充分掌握了匹配引擎的内部机制。<br>正则表达式语言相对小型和受限（功能有限），因此并非所有字符串处理都能用正则表达式完成。当然也有些任务可以用正则表达式完成，不过最终表达式会变得异 常复杂。碰到这些情形时，编写 Python 代码进行处理可能反而更好；尽管 Python 代码比一个精巧的正则表达式要慢些，但它更易理解。</p>
<p>&nbsp;</p>
<h3 id="u7B80_u5355_u6A21_u5F0F"><a href="#u7B80_u5355_u6A21_u5F0F" class="headerlink" title="简单模式"></a><span class="mw-headline">简单模式 </span></h3><p>我们将从最简单的正则表达式学习开始。由于正则表达式常用于字符串操作，那我们就从最常见的任务：字符匹配 下手。<br>有关正则表达式底层的计算机科学上的详细解释（确定性和非确定性有限自动机），你可以查阅编写编译器相关的任何教科书。</p>
<p>&nbsp;</p>
<h4 id="u5B57_u7B26_u5339_u914D"><a href="#u5B57_u7B26_u5339_u914D" class="headerlink" title="字符匹配"></a><span class="mw-headline"> 字符匹配 </span></h4><p>大多数字母和字符一般都会和自身匹配。例如，正则表达式 test 会和字符串“test”完全匹配。（你也可以使用大小写不敏感模式，它还能让这个 RE 匹配“Test”或“TEST”；稍后会有更多解释。）</p>
<p>这个规则当然会有例外；有些字符比较特殊，它们和自身并不匹配，而是会表明应和一些特殊的东西匹配，或者它们会影响到 RE 其它部分的重复次数。本文很大篇幅专门讨论了各种元字符及其作用。</p>
<p>这里有一个元字符的完整列表；其含义会在本指南余下部分进行讨论。<a id="more"></a></p>
<pre class="">. ^ $ * + ? { [ ] \ | ( )</pre>
我们首先考察的元字符是"[" 和 "]"。它们常用来指定一个字符类别，所谓字符类别就是你想匹配的一个字符集。字符可以单个列出，也可以用“-”号分隔的两个给定字符来表示一个字符区 间。例如，[abc] 将匹配"a", "b", 或 "c"中的任意一个字符；也可以用区间[a-c]来表示同一字符集，和前者效果一致。如果你只想匹配小写字母，那么 RE 应写成 [a-z].

元字符在类别里并不起作用。例如，[akm$]将匹配字符"a", "k", "m", 或 "$" 中的任意一个；"$"通常用作元字符，但在字符类别里，其特性被除去，恢复成普通字符。

你可以用补集来匹配不在区间范围内的字符。其做法是把"^"作为类别的首个字符；其它地方的"^"只会简单匹配 "^"字符本身。例如，[^5] 将匹配除 "5" 之外的任意字符。

也许最重要的元字符是反斜杠"\"。 做为 Python 中的字符串字母，反斜杠后面可以加不同的字符以表示不同特殊意义。它也可以用于取消所有的元字符，这样你就可以在模式中匹配它们了。举个例子，如果你需要 匹配字符 "[" 或 "\"，你可以在它们之前用反斜杠来取消它们的特殊意义： \[ 或 \\。

一些用 "\" 开始的特殊字符所表示的预定义字符集通常是很有用的，象数字集，字母集，或其它非空字符集。下列是可用的预设特殊字符：
<pre class="">\d  匹配任何十进制数；它相当于类 [0-9]。
\D  匹配任何非数字字符；它相当于类 [^0-9]。
\s  匹配任何空白字符；它相当于类  [ \t\n\r\f\v]。
\S  匹配任何非空白字符；它相当于类 [^ \t\n\r\f\v]。
\w  匹配任何字母数字字符；它相当于类 [a-zA-Z0-9_]。
\W  匹配任何非字母数字字符；它相当于类 [^a-zA-Z0-9_]。
</pre>
这样特殊字符都可以包含在一个字符类中。如，[\s,.]字符类将匹配任何空白字符或","或"."。

本节最后一个元字符是 . 。它匹配除了换行字符外的任何字符，在 alternate 模式（re.DOTALL）下它甚至可以匹配换行。"." 通常被用于你想匹配“任何字符”的地方。

&nbsp;

#### <span class="mw-headline">重复 </span>

正则表达式第一件能做的事是能够匹配不定长的字符集，而这是其它能作用在字符串上的方法所不能做到的。 不过，如果那是正则表达式唯一的附加功能的话，那么它们也就不那么优秀了。它们的另一个功能就是你可以指定正则表达式的一部分的重复次数。

我们讨论的第一个重复功能的元字符是 *。* 并不匹配字母字符 "*"；相反，它指定前一个字符可以被匹配零次或更多次，而不是只有一次。

举个例子，ca*t 将匹配 "ct" (0 个 "a" 字符), "cat" (1 个 "a"), "caaat" (3 个 "a" 字符)等等。RE 引擎有各种来自 C 的整数类型大小的内部限制，以防止它匹配超过20亿个 "a" 字符；你也许没有足够的内存去建造那么大的字符串，所以将不会累计到那个限制。

象 * 这样地重复是“贪婪的”；当重复一个 RE 时，匹配引擎会试着重复尽可能多的次数。如果模式的后面部分没有被匹配，匹配引擎将退回并再次尝试更小的重复。
一步步的示例可以使它更加清晰。让我们考虑表达式 a[bcd]*b。它匹配字母 "a"，零个或更多个来自类 [bcd]中的字母，最后以 "b" 结尾。现在想一想该 RE 对字符串 "abcbd" 的匹配。
<table border="1" cellspacing="0">
<tbody>
<tr>
<td>Step</td>
<td>Matched</td>
<td>Explanation</td>
</tr>
<tr>
<td>1</td>
<td>a</td>
<td>a 匹配模式</td>
</tr>
<tr>
<td>2</td>
<td>abcbd</td>
<td>引擎匹配 [bcd]*，并尽其所能匹配到字符串的结尾</td>
</tr>
<tr>
<td>3</td>
<td>Failure</td>
<td>引擎尝试匹配 b，但当前位置已经是字符的最后了，所以失败</td>
</tr>
<tr>
<td>4</td>
<td>abcb</td>
<td>退回，[bcd]*尝试少匹配一个字符。</td>
</tr>
<tr>
<td>5</td>
<td>Failure</td>
<td>再次尝次b，但在当前最后一位字符是"d"。</td>
</tr>
<tr>
<td>6</td>
<td>abc</td>
<td>再次退回，[bcd]*只匹配 "bc"。</td>
</tr>
<tr>
<td>7</td>
<td>abcb</td>
<td>再次尝试 b ，这次当前位上的字符正好是 "b"</td>
</tr>
</tbody>
</table>
RE 的结尾部分现在可以到达了，它匹配 "abcb"。这证明了匹配引擎一开始会尽其所能进行匹配，如果没有匹配然后就逐步退回并反复尝试 RE 剩下来的部分。直到它退回尝试匹配 [bcd] 到零次为止，如果随后还是失败，那么引擎就会认为该字符串根本无法匹配 RE 。
另一个重复元字符是 +，表示匹配一或更多次。请注意 * 和 + 之间的不同；* 匹配零或更多次，所以可以根本就不出现，而 + 则要求至少出现一次。用同一个例子，ca+t 就可以匹配 "cat" (1 个 "a")， "caaat" (3 个 "a")， 但不能匹配 "ct"。
还有更多的限定符。问号 ? 匹配一次或零次；你可以认为它用于标识某事物是可选的。例如：home-?brew 匹配 "homebrew" 或 "home-brew"。
最复杂的重复限定符是 {m,n}(注意m,n之间不能有空格)，其中 m 和 n 是十进制整数。该限定符的意思是至少有 m 个重复，至多到 n 个重复。举个例子，a/{1,3}b 将匹配 "a/b"，"a//b" 和 "a///b"。它不能匹配 "ab" 因为没有斜杠，也不能匹配 "a////b" ，因为有四个。
你可以忽略 m 或 n；因为会为缺失的值假设一个合理的值。忽略 m 会认为下边界是 0，而忽略 n 的结果将是上边界为无穷大 -- 实际上是先前我们提到的20亿，但这也许同无穷大一样。
细心的读者也许注意到其他三个限定符都可以用这样方式来表示。 {0,} 等同于 *，{1,} 等同于 +，而{0,1}则与 ? 相同。如果可以的话，最好使用 *，+，或?。很简单因为它们更短也更容易懂。

&nbsp;

### <span class="mw-headline">使用正则表达式 </span>

现在我们已经看了一些简单的正则表达式，那么我们实际在 Python 中是如何使用它们的呢？ re 模块提供了一个正则表达式引擎的接口，可以让你将 REs 编译成对象并用它们来进行匹配。

&nbsp;

#### <span class="mw-headline">编译正则表达式 </span>

正则表达式被编译成 `RegexObject` 实例，可以为不同的操作提供方法，如模式匹配搜索或字符串替换。
<pre class="lang:default decode:true ">#python
&gt;&gt;&gt; import re
&gt;&gt;&gt; p = re.compile('ab*')
&gt;&gt;&gt; print p
&lt;_sre.SRE_Pattern object at 0xb76e1a70&gt;</pre>
re.compile() 也接受可选的标志参数，常用来实现不同的特殊功能和语法变更。我们稍后将查看所有可用的设置，但现在只举一个例子：
<pre class="lang:default decode:true">#!python
&gt;&gt;&gt; p = re.compile('ab*', re.IGNORECASE)</pre>
RE 被做为一个字符串发送给 re.compile()。REs 被处理成字符串是因为正则表达式不是 Python 语言的核心部分，也没有为它创建特定的语法。（应用程序根本就不需要 REs，因此没必要包含它们去使语言说明变得臃肿不堪。）而 re 模块则只是以一个 C 扩展模块的形式来被 Python 包含，就象 socket 或 zlib 模块一样
将 REs 作为字符串以保证 Python 语言的简洁，但这样带来的一个麻烦就是象下节标题所讲的。

&nbsp;

#### <span class="mw-headline">反斜杠的麻烦 </span>

在早期规定中，正则表达式用反斜杠字符 ("\") 来表示特殊格式或允许使用特殊字符而不调用它的特殊用法。这就与 Python 在字符串中的那些起相同作用的相同字符产生了冲突。
让我们举例说明，你想写一个 RE 以匹配字符串 "\section"，可能是在一个 LATEX 文件查找。为了要在程序代码中判断，首先要写出想要匹配的字符串。接下来你需要在所有反斜杠和其它元字符前加反斜杠来取消其特殊意义，结果要匹配的字符串 就成了"\\section"。 当把这个字符串传递给re.compile()时必须还是"\\section"。然而，作为Python的字符串实值(string literals)来表示的话，"\\section"中两个反斜杠还要再次取消特殊意义，最后结果就变成了"\\\\section"。
<table border="1" cellspacing="0">
<tbody>
<tr>
<td>字符</td>
<td>阶段</td>
</tr>
<tr>
<td>\section</td>
<td>要匹配的字符串</td>
</tr>
<tr>
<td>\\section</td>
<td>为 re.compile 取消反斜杠的特殊意义</td>
</tr>
<tr>
<td>"\\\\section"</td>
<td>为"\\section"的字符串实值(string literals)取消反斜杠的特殊意义</td>
</tr>
</tbody>
</table>
简单地说，为了匹配一个反斜杠，不得不在 RE 字符串中写 '\\\\'，因为正则表达式中必须是 "\\"，而每个反斜杠在常规的 Python 字符串实值中必须表示成 "\\"。在 REs 中反斜杠的这个重复特性会导致大量重复的反斜杠，而且所生成的字符串也很难懂。

解决的办法就是为正则表达式使用 Python 的 raw 字符串表示；在字符串前加个 "r" 反斜杠就不会被任何特殊方式处理，所以 r"\n" 就是包含"\" 和 "n" 的两个字符，而 "\n" 则是一个字符，表示一个换行。正则表达式通常在 Python 代码中都是用这种 raw 字符串表示。
<table border="1" cellspacing="0">
<tbody>
<tr>
<td>常规字符串</td>
<td>Raw 字符串</td>
</tr>
<tr>
<td>"ab*"</td>
<td>r"ab*"</td>
</tr>
<tr>
<td>"\\\\section"</td>
<td>r"\\section"</td>
</tr>
<tr>
<td>"\\w+\\s+\\1"</td>
<td>r"\w+\s+\1"</td>
</tr>
</tbody>
</table>
&nbsp;

#### <span class="mw-headline"> 执行匹配 </span>

一旦你有了已经编译了的正则表达式的对象，你要用它做什么呢？`RegexObject` 实例有一些方法和属性。这里只显示了最重要的几个，如果要看完整的列表请查阅 Python Library Reference
<table border="1" cellspacing="0">
<tbody>
<tr>
<td>方法/属性</td>
<td>作用</td>
</tr>
<tr>
<td>match()</td>
<td>决定 RE 是否在字符串刚开始的位置匹配</td>
</tr>
<tr>
<td>search()</td>
<td>扫描字符串，找到这个 RE 匹配的位置</td>
</tr>
<tr>
<td>findall()</td>
<td>找到 RE 匹配的所有子串，并把它们作为一个列表返回</td>
</tr>
<tr>
<td>finditer()</td>
<td>找到 RE 匹配的所有子串，并把它们作为一个迭代器返回</td>
</tr>
</tbody>
</table>
如果没有匹配到的话，match() 和 search() 将返回 None。如果成功的话，就会返回一个 `MatchObject` 实例，其中有这次匹配的信息：它是从哪里开始和结束，它所匹配的子串等等。

你可以用采用人机对话并用 re 模块实验的方式来学习它。如果你有 Tkinter 的话，你也许可以考虑参考一下 Tools/scripts/redemo.py，一个包含在 Python 发行版里的示范程序。

首先，运行 Python 解释器，导入 re 模块并编译一个 RE：
<pre class="lang:default decode:true">#!python
Python 2.2.2 (#1, Feb 10 2003, 12:57:01)
&gt;&gt;&gt; import re
&gt;&gt;&gt; p = re.compile('[a-z]+')
&gt;&gt;&gt; p
&lt;_sre.SRE_Pattern object at 80c3c28&gt;</pre>
现在，你可以试着用 RE 的 [a-z]+ 去匹配不同的字符串。一个空字符串将根本不能匹配，因为 + 的意思是 “一个或更多的重复次数”。 在这种情况下 match() 将返回 None，因为它使解释器没有输出。你可以明确地打印出 match() 的结果来弄清这一点。
<pre class="lang:default decode:true">#!python
&gt;&gt;&gt; p.match("")
&gt;&gt;&gt; print p.match("")
None</pre>
现在，让我们试着用它来匹配一个字符串，如 "tempo"。这时，match() 将返回一个 MatchObject。因此你可以将结果保存在变量里以便後面使用。
<pre class="lang:default decode:true">#!python
&gt;&gt;&gt; m = p.match( 'tempo')
&gt;&gt;&gt; print m
&lt;_sre.SRE_Match object at 80c4f68&gt;</pre>
现在你可以查询 `MatchObject` 关于匹配字符串的相关信息了。MatchObject 实例也有几个方法和属性；最重要的那些如下所示：
<table border="1" cellspacing="0">
<tbody>
<tr>
<td>方法/属性</td>
<td>作用</td>
</tr>
<tr>
<td>group()</td>
<td>返回被 RE 匹配的字符串</td>
</tr>
<tr>
<td>start()</td>
<td>返回匹配开始的位置</td>
</tr>
<tr>
<td>end()</td>
<td>返回匹配结束的位置</td>
</tr>
<tr>
<td>span()</td>
<td>返回一个元组包含匹配 (开始,结束) 的位置</td>
</tr>
</tbody>
</table>
试试这些方法不久就会清楚它们的作用了：
<pre class="lang:default decode:true">#!python
&gt;&gt;&gt; m.group()
'tempo'
&gt;&gt;&gt; m.start(), m.end()
(0, 5)
&gt;&gt;&gt; m.span()
(0, 5)</pre>
group() 返回 RE 匹配的子串。start() 和 end() 返回匹配开始和结束时的索引。span() 则用单个元组把开始和结束时的索引一起返回。因为匹配方法检查到如果 RE 在字符串开始处开始匹配，那么 start() 将总是为零。然而， `RegexObject` 实例的 search 方法扫描下面的字符串的话，在这种情况下，匹配开始的位置就也许不是零了。
<pre class="lang:default decode:true">#!python
&gt;&gt;&gt; print p.match('::: message')
None
&gt;&gt;&gt; m = p.search('::: message') ; print m
&lt;re.MatchObject instance at 80c9650&gt;
&gt;&gt;&gt; m.group()
'message'
&gt;&gt;&gt; m.span()
(4, 11)</pre>
在实际程序中，最常见的作法是将 `MatchObject` 保存在一个变量里，然後检查它是否为 None，通常如下所示：
<pre class="lang:default decode:true">#!python
p = re.compile( ... )
m = p.match( 'string goes here' )
if m:
print 'Match found: ', m.group()
else:
print 'No match'</pre>
两个 `RegexObject` 方法返回所有匹配模式的子串。findall()返回一个匹配字符串行表：
<pre class="lang:default decode:true">#!python
&gt;&gt;&gt; p = re.compile('\d+')
&gt;&gt;&gt; p.findall('12 drummers drumming, 11 pipers piping, 10 lords a-leaping')
['12', '11', '10']</pre>
findall() 在它返回结果时不得不创建一个列表。在 Python 2.2中，也可以用 finditer() 方法。
<pre class="lang:default decode:true">#!python
&gt;&gt;&gt; iterator = p.finditer('12 drummers drumming, 11 ... 10 ...')
&gt;&gt;&gt; iterator
&lt;callable-iterator object at 0x401833ac&gt;
&gt;&gt;&gt; for match in iterator:
...     print match.span()
...
(0, 2)
(22, 24)
(29, 31)</pre>

<h4 id="u6A21_u5757_u7EA7_u51FD_u6570"><a href="#u6A21_u5757_u7EA7_u51FD_u6570" class="headerlink" title="模块级函数"></a><span class="mw-headline">模块级函数 </span></h4><p>你不一定要产生一个 <code>RegexObject</code> 对象然后再调用它的方法；re 模块也提供了顶级函数调用如 match()、search()、sub() 等等。这些函数使用 RE 字符串作为第一个参数，而后面的参数则与相应 <code>RegexObject</code> 的方法参数相同，返回则要么是 None 要么就是一个 <code>MatchObject</code> 的实例。</p>
<p><pre class="lang:default decode:true">#!python<br>&gt;&gt;&gt; print re.match(r’From\s+’, ‘Fromage amk’)<br>None<br>&gt;&gt;&gt; re.match(r’From\s+’, ‘From amk Thu May 14 19:12:10 1998’)<br>&lt;re.MatchObject instance at 80c5978&gt;</pre><br>Under the hood, 这些函数简单地产生一个 RegexOject 并在其上调用相应的方法。它们也在缓存里保存编译后的对象，因此在将来调用用到相同 RE 时就会更快。<br>你将使用这些模块级函数，还是先得到一个 <code>RegexObject</code> 再调用它的方法呢？如何选择依赖于怎样用 RE 更有效率以及你个人编码风格。如果一个 RE 在代码中只做用一次的话，那么模块级函数也许更方便。如果程序包含很多的正则表达式，或在多处复用同一个的话，那么将全部定义放在一起，在一段代码中提前 编译所有的 REs 更有用。从标准库中看一个例子，这是从 xmllib.py 文件中提取出来的：</p>
<p><pre class="lang:default decode:true">#!python<br>ref = re.compile( … )<br>entityref = re.compile( … )<br>charref = re.compile( … )<br>starttagopen = re.compile( … )</pre><br>我通常更喜欢使用编译对象，甚至它只用一次，但很少人会像我这样做(如同一个纯粹主义者)。</p>
<p>&nbsp;</p>
<h4 id="u7F16_u8BD1_u6807_u5FD7"><a href="#u7F16_u8BD1_u6807_u5FD7" class="headerlink" title="编译标志"></a><span class="mw-headline">编译标志 </span></h4><p>编译标志让你可以修改正则表达式的一些运行方式。在 re 模块中标志可以使用两个名字，一个是全名如 IGNORECASE，一个是缩写，一字母形式如 I。（如果你熟悉 Perl 的模式修改，一字母形式使用同样的字母；例如 re.VERBOSE的缩写形式是 re.X。）多个标志可以通过按位 OR-ing 它们来指定。如 re.I | re.M 被设置成 I 和 M 标志：<br>这有个可用标志表，对每个标志后面都有详细的说明。</p>
<p><table border="1" cellspacing="0"></table></p>
<p><tbody></tbody></p>
<p><tr></tr></p>
<p><td>标志</td></p>
<p><td>含义</td><br></p>
<p><tr></tr></p>
<p><td>DOTALL, S</td></p>
<p><td>使 . 匹配包括换行在内的所有字符</td><br></p>
<p><tr></tr></p>
<p><td>IGNORECASE, I</td></p>
<p><td>使匹配对大小写不敏感</td><br></p>
<p><tr></tr></p>
<p><td>LOCALE, L</td></p>
<p><td>做本地化识别（locale-aware）匹配</td><br></p>
<p><tr></tr></p>
<p><td>MULTILINE, M</td></p>
<p><td>多行匹配，影响 ^ 和 $</td><br></p>
<p><tr></tr></p>
<p><td>VERBOSE, X</td></p>
<p><td>能够使用 REs 的 verbose 状态，使之被组织得更清晰易懂</td><br><br><br><br><strong>I</strong><br><strong>IGNORECASE</strong></p>
<p>使匹配对大小写不敏感；字符类和字符串匹配字母时忽略大小写。举个例子，[A-Z]也可以匹配小写字母，Spam 可以匹配 “Spam”, “spam”, 或 “spAM”。这个小写字母并不考虑当前位置。</p>
<p><strong>L</strong><br><strong>LOCALE</strong></p>
<p>影响 \w, \W, \b, 和 \B，这取决于当前的本地化设置。</p>
<p>locales 是 C 语言库中的一项功能，是用来为需要考虑不同语言的编程提供帮助的。举个例子，如果你正在处理法文文本，你想用 \w+ 来匹配文字，但 \w 只匹配字符类 [A-Za-z]；它并不能匹配 “é” 或 “ç”。如果你的系统配置适当且本地化设置为法语，那么内部的 C 函数将告诉程序 “é” 也应该被认为是一个字母。当在编译正则表达式时使用 LOCALE 标志会得到用这些 C 函数来处理 \w 后的编译对象；这会更慢，但也会象你希望的那样可以用 \w+ 来匹配法文文本。</p>
<p><strong>M</strong><br><strong>MULTILINE</strong><br>(此时 ^ 和 $ 不会被解释; 它们将在 4.1 节被介绍.)<br>使用 “^” 只匹配字符串的开始，而 $ 则只匹配字符串的结尾和直接在换行前（如果有的话）的字符串结尾。当本标志指定后， “^” 匹配字符串的开始和字符串中每行的开始。同样的， $ 元字符匹配字符串结尾和字符串中每行的结尾（直接在每个换行之前）。</p>
<p><strong>S</strong><br><strong>DOTALL</strong></p>
<p>使 “.” 特殊字符完全匹配任何字符，包括换行；没有这个标志， “.” 匹配除了换行外的任何字符。</p>
<p><strong>X</strong><br><strong>VERBOSE</strong><br>该标志通过给予你更灵活的格式以便你将正则表达式写得更易于理解。当该标志被指定时，在 RE 字符串中的空白符被忽略，除非该空白符在字符类中或在反斜杠之后；这可以让你更清晰地组织和缩进 RE。它也可以允许你将注释写入 RE，这些注释会被引擎忽略；注释用 “#”号 来标识，不过该符号不能在字符串或反斜杠之后。<br>举个例子，这里有一个使用 re.VERBOSE 的 RE；看看读它轻松了多少？</p>
<p><pre class="lang:default decode:true">#!python<br>charref = re.compile(r”””&amp;[[]]           # Start of a numeric entity reference|||here has wrong.i can’t fix<br>(<br>[0-9]+[^0-9]      # Decimal form<br>| 0[0-7]+[^0-7]   # Octal form<br>| x[0-9a-fA-F]+[^0-9a-fA-F] # Hexadecimal form<br>)<br>“””, re.VERBOSE)</pre><br>没有 verbose 设置， RE 会看起来象这样：</p>
<p><pre class="lang:default decode:true">#!python<br>charref = re.compile(“&amp;#([0-9]+[^0-9]”<br>“|0[0-7]+[^0-7]”<br>“|x[0-9a-fA-F]+[^0-9a-fA-F])”)</pre><br>在上面的例子里，Python 的字符串自动连接可以用来将 RE 分成更小的部分，但它比用 re.VERBOSE 标志时更难懂</p>
<p>&nbsp;</p>
<h3 id="u66F4_u591A_u6A21_u5F0F_u529F_u80FD"><a href="#u66F4_u591A_u6A21_u5F0F_u529F_u80FD" class="headerlink" title="更多模式功能"></a><span class="mw-headline">更多模式功能 </span></h3><p>到目前为止，我们只展示了正则表达式的一部分功能。在本节，我们将展示一些新的元字符和如何使用组来检索被匹配的文本部分。</p>
<p>== ==</p>
<p>&nbsp;</p>
<h4 id="u66F4_u591A_u7684_u5143_u5B57_u7B26"><a href="#u66F4_u591A_u7684_u5143_u5B57_u7B26" class="headerlink" title="更多的元字符"></a><span class="mw-headline">更多的元字符 </span></h4><p><strong>粗体文字</strong><a href="http://www.example.com" title="http://www.example.com" target="_blank" rel="external">链接标题</a>还有一些我们还没展示的元字符，其中的大部分将在本节展示。<br>剩下来要讨论的一部分元字符是零宽界定符（zero-width assertions）。它们并不会使引擎在处理字符串时更快;相反，它们根本就没有对应任何字符，只是简单的成功或失败。举个例子， \b 是一个在单词边界定位当前位置的界定符（assertions），这个位置根本就不会被 \b 改变。这意味着零宽界定符（zero-width assertions）将永远不会被重复，因为如果它们在给定位置匹配一次，那么它们很明显可以被匹配无数次。</p>
<p><strong>|</strong><br>可选项，或者 “or” 操作符。如果 A 和 B 是正则表达式，A|B 将匹配任何匹配了 “A” 或 “B” 的字符串。| 的优先级非常低，是为了当你有多字符串要选择时能适当地运行。Crow|Servo 将匹配”Crow” 或 “Servo”, 而不是 “Cro”, 一个 “w” 或 一个 “S”, 和 “ervo”。<br>为了匹配字母 “|”，可以用 |，或将其包含在字符类中，如[|]。</p>
<p><strong>^</strong><br>匹配行首。除非设置 MULTILINE 标志，它只是匹配字符串的开始。在 MULTILINE 模式里，它也可以直接匹配字符串中的每个换行。<br>例如，如果你只希望匹配在行首单词 “From”，那么 RE 将用 ^From。</p>
<p><pre class="lang:default decode:true">#!python<br>&gt;&gt;&gt; print re.search(‘^From’, ‘From Here to Eternity’)<br>&lt;re.MatchObject instance at 80c1520&gt;<br>&gt;&gt;&gt; print re.search(‘^From’, ‘Reciting From Memory’)<br>None</pre><br><strong>$</strong><br>匹配行尾，行尾被定义为要么是字符串尾，要么是一个换行字符后面的任何位置。</p>
<p><pre class="lang:default decode:true">#!python<br>&gt;&gt;&gt; print re.search(‘}$’, ‘{block}’)<br>&lt;re.MatchObject instance at 80adfa8&gt;<br>&gt;&gt;&gt; print re.search(‘}$’, ‘{block} ‘)<br>None<br>&gt;&gt;&gt; print re.search(‘}$’, ‘{block}\n’)<br>&lt;re.MatchObject instance at 80adfa8&gt;</pre><br>匹配一个 “$”，使用 \$ 或将其包含在字符类中，如[$]。</p>
<p><strong>\A</strong><br>只匹配字符串首。当不在 MULTILINE 模式，\A 和 ^ 实际上是一样的。然而，在 MULTILINE 模式里它们是不同的；\A 只是匹配字符串首，而 ^ 还可以匹配在换行符之后字符串的任何位置。</p>
<p><strong>\Z</strong></p>
<p>Matches only at the end of the string.<br>只匹配字符串尾。</p>
<p><strong>\b</strong></p>
<p>单词边界。这是个零宽界定符（zero-width assertions）只用以匹配单词的词首和词尾。单词被定义为一个字母数字序列，因此词尾就是用空白符或非字母数字符来标示的。<br>下面的例子只匹配 “class” 整个单词；而当它被包含在其他单词中时不匹配。</p>
<p><pre class="lang:default decode:true">#!python<br>&gt;&gt;&gt; p = re.compile(r’\bclass\b’)<br>&gt;&gt;&gt; print p.search(‘no class at all’)<br>&lt;re.MatchObject instance at 80c8f28&gt;<br>&gt;&gt;&gt; print p.search(‘the declassified algorithm’)<br>None<br>&gt;&gt;&gt; print p.search(‘one subclass is’)<br>None</pre><br>当用这个特殊序列时你应该记住这里有两个微妙之处。第一个是 Python 字符串和正则表达式之间最糟的冲突。在 Python 字符串里，”\b” 是反斜杠字符，ASCII值是8。如果你没有使用 raw 字符串时，那么 Python 将会把 “\b” 转换成一个回退符，你的 RE 将无法象你希望的那样匹配它了。下面的例子看起来和我们前面的 RE 一样，但在 RE 字符串前少了一个 “r” 。</p>
<p><pre class="lang:default decode:true">#!python<br>&gt;&gt;&gt; p = re.compile(‘\bclass\b’)<br>&gt;&gt;&gt; print p.search(‘no class at all’)<br>None<br>&gt;&gt;&gt; print p.search(‘\b’ + ‘class’ + ‘\b’)<br>&lt;re.MatchObject instance at 80c3ee0&gt;</pre><br>第二个在字符类中，这个限定符（assertion）不起作用，\b 表示回退符，以便与 Python 字符串兼容。</p>
<p><strong>\B</strong><br>另一个零宽界定符（zero-width assertions），它正好同 \b 相反，只在当前位置不在单词边界时匹配。</p>
<p>&nbsp;</p>
<h4 id="u5206_u7EC4"><a href="#u5206_u7EC4" class="headerlink" title="分组"></a><span class="mw-headline">分组 </span></h4><p>你经常需要得到比 RE 是否匹配还要多的信息。正则表达式常常用来分析字符串，编写一个 RE 匹配感兴趣的部分并将其分成几个小组。举个例子，一个 RFC-822 的头部用 “:” 隔成一个头部名和一个值，这就可以通过编写一个正则表达式匹配整个头部，用一组匹配头部名，另一组匹配头部值的方式来处理。<br>组是通过 “(“ 和 “)” 元字符来标识的。 “(“ 和 “)” 有很多在数学表达式中相同的意思；它们一起把在它们里面的表达式组成一组。举个例子，你可以用重复限制符，象 <em>, +, ?, 和 {m,n}，来重复组里的内容，比如说(ab)</em> 将匹配零或更多个重复的 “ab”。</p>
<p><pre class="lang:default decode:true">#!python<br>&gt;&gt;&gt; p = re.compile(‘(ab)*’)<br>&gt;&gt;&gt; print p.match(‘ababababab’).span()<br>(0, 10)</pre><br>组用 “(“ 和 “)” 来指定，并且得到它们匹配文本的开始和结尾索引；这就可以通过一个参数用 group()、start()、end() 和 span() 来进行检索。组是从 0 开始计数的。组 0 总是存在；它就是整个 RE，所以 <code>MatchObject</code> 的方法都把组 0 作为它们缺省的参数。稍后我们将看到怎样表达不能得到它们所匹配文本的 span。</p>
<p><pre class="lang:default decode:true">#!python<br>&gt;&gt;&gt; p = re.compile(‘(a)b’)<br>&gt;&gt;&gt; m = p.match(‘ab’)<br>&gt;&gt;&gt; m.group()<br>‘ab’<br>&gt;&gt;&gt; m.group(0)<br>‘ab’</pre><br>小组是从左向右计数的，从1开始。组可以被嵌套。计数的数值可以通过从左到右计算打开的括号数来确定。</p>
<p><pre class="lang:default decode:true">#!python<br>&gt;&gt;&gt; p = re.compile(‘(a(b)c)d’)<br>&gt;&gt;&gt; m = p.match(‘abcd’)<br>&gt;&gt;&gt; m.group(0)<br>‘abcd’<br>&gt;&gt;&gt; m.group(1)<br>‘abc’<br>&gt;&gt;&gt; m.group(2)<br>‘b’</pre><br>group() 可以一次输入多个组号，在这种情况下它将返回一个包含那些组所对应值的元组。</p>
<p><pre class="lang:default decode:true">#!python<br>&gt;&gt;&gt; m.group(2,1,2)<br>(‘b’, ‘abc’, ‘b’)</pre><br>The groups() 方法返回一个包含所有小组字符串的元组，从 1 到 所含的小组号。</p>
<p><pre class="lang:default decode:true">#!python<br>&gt;&gt;&gt; m.groups()<br>(‘abc’, ‘b’)</pre><br>模式中的逆向引用允许你指定先前捕获组的内容，该组也必须在字符串当前位置被找到。举个例子，如果组 1 的内容能够在当前位置找到的话，\1 就成功否则失败。记住 Python 字符串也是用反斜杠加数据来允许字符串中包含任意字符的，所以当在 RE 中使用逆向引用时确保使用 raw 字符串。<br>例如，下面的 RE 在一个字符串中找到成双的词。</p>
<p><pre class="lang:default decode:true">#!python<br>&gt;&gt;&gt; p = re.compile(r’(\b\w+)\s+\1’)<br>&gt;&gt;&gt; p.search(‘Paris in the the spring’).group()<br>‘the the’</pre><br>象这样只是搜索一个字符串的逆向引用并不常见 – 用这种方式重复数据的文本格式并不多见 – 但你不久就可以发现它们用在字符串替换上非常有用。</p>
<p>&nbsp;</p>
<h4 id="u65E0_u6355_u83B7_u7EC4_u548C_u547D_u540D_u7EC4"><a href="#u65E0_u6355_u83B7_u7EC4_u548C_u547D_u540D_u7EC4" class="headerlink" title="无捕获组和命名组"></a><span class="mw-headline">无捕获组和命名组 </span></h4><p>精心设计的 REs 也许会用很多组，既可以捕获感兴趣的子串，又可以分组和结构化 RE 本身。在复杂的 REs 里，追踪组号变得困难。有两个功能可以对这个问题有所帮助。它们也都使用正则表达式扩展的通用语法，因此我们来看看第一个。<br>Perl 5 对标准正则表达式增加了几个附加功能，Python 的 re 模块也支持其中的大部分。选择一个新的单按键元字符或一个以 “\” 开始的特殊序列来表示新的功能，而又不会使 Perl 正则表达式与标准正则表达式产生混乱是有难度的。如果你选择 “&amp;” 做为新的元字符，举个例子，老的表达式认为 “&amp;” 是一个正常的字符，而不会在使用 \&amp; 或 [&amp;] 时也不会转义。<br>Perl 开发人员的解决方法是使用 (?…) 来做为扩展语法。”?” 在括号后面会直接导致一个语法错误，因为 “?” 没有任何字符可以重复，因此它不会产生任何兼容问题。紧随 “?” 之后的字符指出扩展的用途，因此 (?=foo)<br>Python 新增了一个扩展语法到 Perl 扩展语法中。如果在问号后的第一个字符是 “P”，你就可以知道它是针对 Python 的扩展。目前有两个这样的扩展: (?P&lt;name&gt;…) 定义一个命名组，(?P=name) 则是对命名组的逆向引用。如果 Perl 5 的未来版本使用不同的语法增加了相同的功能，那么 re 模块也将改变以支持新的语法，与此同时为了兼容性的目的而继续保持的 Python 专用语法。<br>现在我们看一下普通的扩展语法，我们回过头来简化在复杂 REs 中使用组运行的特性。因为组是从左到右编号的，而且一个复杂的表达式也许会使用许多组，它可以使跟踪当前组号变得困难，而修改如此复杂的 RE 是十分麻烦的。在开始时插入一个新组，你可以改变它之后的每个组号。<br>首先，有时你想用一个组去收集正则表达式的一部分，但又对组的内容不感兴趣。你可以用一个无捕获组: (?:…) 来实现这项功能，这样你可以在括号中发送任何其他正则表达式。</p>
<p><pre class="lang:default decode:true">#!python<br>&gt;&gt;&gt; m = re.match(“([abc])+”, “abc”)<br>&gt;&gt;&gt; m.groups()<br>(‘c’,)<br>&gt;&gt;&gt; m = re.match(“(?:[abc])+”, “abc”)<br>&gt;&gt;&gt; m.groups()<br>()</pre><br>除了捕获匹配组的内容之外，无捕获组与捕获组表现完全一样；你可以在其中放置任何字符，可以用重复元字符如 “*” 来重复它，可以在其他组（无捕获组与捕获组）中嵌套它。(?:…) 对于修改已有组尤其有用，因为你可以不用改变所有其他组号的情况下添加一个新组。捕获组和无捕获组在搜索效率方面也没什么不同，没有哪一个比另一个更快。<br>其次，更重要和强大的是命名组；与用数字指定组不同的是，它可以用名字来指定。<br>命令组的语法是 Python 专用扩展之一： (?P&lt;name&gt;…)。名字很明显是组的名字。除了该组有个名字之外，命名组也同捕获组是相同的。<code>MatchObject</code> 的方法处理捕获组时接受的要么是表示组号的整数，要么是包含组名的字符串。命名组也可以是数字，所以你可以通过两种方式来得到一个组的信息：</p>
<p><pre class="lang:default decode:true">#!python<br>&gt;&gt;&gt; p = re.compile(r’(?P&lt;word&gt;\b\w+\b)’)<br>&gt;&gt;&gt; m = p.search( ‘(((( Lots of punctuation )))’ )<br>&gt;&gt;&gt; m.group(‘word’)<br>‘Lots’<br>&gt;&gt;&gt; m.group(1)<br>‘Lots’</pre><br>命名组是便于使用的，因为它可以让你使用容易记住的名字来代替不得不记住的数字。这里有一个来自 imaplib 模块的 RE 示例：</p>
<p><pre class="lang:default decode:true">#!python<br>InternalDate = re.compile(r’INTERNALDATE “‘<br>r’(?P&lt;day&gt;[ 123][0-9])-(?P&lt;mon&gt;[A-Z][a-z][a-z])-‘<br>  r’(?P&lt;year&gt;[0-9][0-9][0-9][0-9])’<br>r’ (?P&lt;hour&gt;[0-9][0-9]):(?P&lt;min&gt;[0-9][0-9]):(?P&lt;sec&gt;[0-9][0-9])’<br>r’ (?P&lt;zonen&gt;[-+])(?P&lt;zoneh&gt;[0-9][0-9])(?P&lt;zonem&gt;[0-9][0-9])’<br>r’”‘)</pre><br>很明显，得到 m.group(‘zonem’) 要比记住得到组 9 要容易得多。<br>因为逆向引用的语法，象 (…)\1 这样的表达式所表示的是组号，这时用组名代替组号自然会有差别。还有一个 Python 扩展：(?P=name) ，它可以使叫 name 的组内容再次在当前位置发现。正则表达式为了找到重复的单词，(\b\w+)\s+\1 也可以被写成 (?P&lt;word&gt;\b\w+)\s+(?P=word)：</p>
<p><pre class="lang:default decode:true">#!python<br>&gt;&gt;&gt; p = re.compile(r’(?P&lt;word&gt;\b\w+)\s+(?P=word)’)<br>&gt;&gt;&gt; p.search(‘Paris in the the spring’).group()<br>‘the the’</pre><br>&nbsp;</p>
<h4 id="u524D_u5411_u754C_u5B9A_u7B26"><a href="#u524D_u5411_u754C_u5B9A_u7B26" class="headerlink" title="前向界定符"></a><span class="mw-headline">前向界定符 </span></h4><p>另一个零宽界定符（zero-width assertion）是前向界定符。前向界定符包括前向肯定界定符和前项否定界定符，如下所示：</p>
<p><strong>(?=…)</strong></p>
<p>前向肯定界定符。如果所含正则表达式，以 … 表示，在当前位置成功匹配时成功，否则失败。但一旦所含表达式已经尝试，匹配引擎根本没有提高；模式的剩余部分还要尝试界定符的右边。</p>
<p><strong>(?!…)</strong></p>
<p>前向否定界定符。与肯定界定符相反；当所含表达式不能在字符串当前位置匹配时成功<br>通过示范在哪前向可以成功有助于具体实现。考虑一个简单的模式用于匹配一个文件名，并将其通过 “.” 分成基本名和扩展名两部分。如在 “news.rc” 中，”news” 是基本名，”rc” 是文件的扩展名。<br>匹配模式非常简单：</p>
<p><pre>.<em>[.].</em>$<br></pre><br>注意 “.” 需要特殊对待，因为它是一个元字符；我把它放在一个字符类中。另外注意后面的 $; 添加这个是为了确保字符串所有的剩余部分必须被包含在扩展名中。这个正则表达式匹配 “foo.bar”、”autoexec.bat”、 “sendmail.cf” 和 “printers.conf”。<br>现在，考虑把问题变得复杂点；如果你想匹配的扩展名不是 “bat” 的文件名？一些不正确的尝试：</p>
<p><pre>.<em>[.][^b].</em>$<br></pre><br>上面的第一次去除 “bat” 的尝试是要求扩展名的第一个字符不是 “b”。这是错误的，因为该模式也不能匹配 “foo.bar”。</p>
<p><pre>.*<a href="/[^b]..|.[^a].|..[^t]">.</a>$<br></pre><br>当你试着修补第一个解决方法而要求匹配下列情况之一时表达式更乱了：扩展名的第一个字符不是 “b”; 第二个字符不是 “a”；或第三个字符不是 “t”。这样可以接受 “foo.bar” 而拒绝 “autoexec.bat”，但这要求只能是三个字符的扩展名而不接受两个字符的扩展名如 “sendmail.cf”。我们将在努力修补它时再次把该模式变得复杂。</p>
<p><pre>.*<a href="/[^b].?.?|.[^a]?.?|..?[^t]?">.</a>$<br></pre><br>在第三次尝试中，第二和第三个字母都变成可选，为的是允许匹配比三个字符更短的扩展名，如 “sendmail.cf”。<br>该模式现在变得非常复杂，这使它很难读懂。更糟的是，如果问题变化了，你想扩展名不是 “bat” 和 “exe”，该模式甚至会变得更复杂和混乱。<br>前向否定把所有这些裁剪成：</p>
<p><pre>.<em><a href="/?!bat$">.</a>.</em>$<br></pre><br>前向的意思：如果表达式 bat 在这里没有匹配，尝试模式的其余部分；如果 bat$ 匹配，整个模式将失败。后面的 $ 被要求是为了确保象 “sample.batch” 这样扩展名以 “bat” 开头的会被允许。<br>将另一个文件扩展名排除在外现在也容易；简单地将其做为可选项放在界定符中。下面的这个模式将以 “bat” 或 “exe” 结尾的文件名排除在外。</p>
<p><pre>.<em><a href="/?!bat$|exe$">.</a>.</em>$<br></pre><br>&nbsp;</p>
<h3 id="u4FEE_u6539_u5B57_u7B26_u4E32"><a href="#u4FEE_u6539_u5B57_u7B26_u4E32" class="headerlink" title="修改字符串"></a><span class="mw-headline">修改字符串 </span></h3><p>到目前为止，我们简单地搜索了一个静态字符串。正则表达式通常也用不同的方式，通过下面的 <code>RegexObject</code> 方法，来修改字符串。</p>
<p><table border="1" cellspacing="0"></table></p>
<p><tbody></tbody></p>
<p><tr></tr></p>
<p><td>方法/属性</td></p>
<p><td>作用</td><br></p>
<p><tr></tr></p>
<p><td>split()</td></p>
<p><td>将字符串在 RE 匹配的地方分片并生成一个列表，</td><br></p>
<p><tr></tr></p>
<p><td>sub()</td></p>
<p><td>找到 RE 匹配的所有子串，并将其用一个不同的字符串替换</td><br></p>
<p><tr></tr></p>
<p><td>subn()</td></p>
<p><td>与 sub() 相同，但返回新的字符串和替换次数</td><br><br><br><br>&nbsp;</p>
<h4 id="u5C06_u5B57_u7B26_u4E32_u5206_u7247"><a href="#u5C06_u5B57_u7B26_u4E32_u5206_u7247" class="headerlink" title="将字符串分片"></a><span class="mw-headline">将字符串分片 </span></h4><p><code>RegexObject</code> 的 split() 方法在 RE 匹配的地方将字符串分片，将返回列表。它同字符串的 split() 方法相似但提供更多的定界符；split()只支持空白符和固定字符串。就象你预料的那样，也有一个模块级的 re.split() 函数。</p>
<p><pre>split(string [, maxsplit = 0])<br></pre><br>通过正则表达式将字符串分片。如果捕获括号在 RE 中使用，那么它们的内容也会作为结果列表的一部分返回。如果 maxsplit 非零，那么最多只能分出 maxsplit 个分片。<br>你可以通过设置 maxsplit 值来限制分片数。当 maxsplit 非零时，最多只能有 maxsplit 个分片，字符串的其余部分被做为列表的最后部分返回。在下面的例子中，定界符可以是非数字字母字符的任意序列。</p>
<p><pre class="lang:default decode:true">#!python<br>&gt;&gt;&gt; p = re.compile(r’\W+’)<br>&gt;&gt;&gt; p.split(‘This is a test, short and sweet, of split().’)<br>[‘This’, ‘is’, ‘a’, ‘test’, ‘short’, ‘and’, ‘sweet’, ‘of’, ‘split’, ‘’]<br>&gt;&gt;&gt; p.split(‘This is a test, short and sweet, of split().’, 3)<br>[‘This’, ‘is’, ‘a’, ‘test, short and sweet, of split().’]</pre><br>有时，你不仅对定界符之间的文本感兴趣，也需要知道定界符是什么。如果捕获括号在 RE 中使用，那么它们的值也会当作列表的一部分返回。比较下面的调用：</p>
<p><pre class="lang:default decode:true">#!python<br>&gt;&gt;&gt; p = re.compile(r’\W+’)<br>&gt;&gt;&gt; p2 = re.compile(r’(\W+)’)<br>&gt;&gt;&gt; p.split(‘This… is a test.’)<br>[‘This’, ‘is’, ‘a’, ‘test’, ‘’]<br>&gt;&gt;&gt; p2.split(‘This… is a test.’)<br>[‘This’, ‘… ‘, ‘is’, ‘ ‘, ‘a’, ‘ ‘, ‘test’, ‘.’, ‘’]</pre><br>模块级函数 re.split() 将 RE 作为第一个参数，其他一样。</p>
<p><pre class="lang:default decode:true">#!python<br>&gt;&gt;&gt; re.split(‘[\W]+’, ‘Words, words, words.’)<br>[‘Words’, ‘words’, ‘words’, ‘’]<br>&gt;&gt;&gt; re.split(‘([\W]+)’, ‘Words, words, words.’)<br>[‘Words’, ‘, ‘, ‘words’, ‘, ‘, ‘words’, ‘.’, ‘’]<br>&gt;&gt;&gt; re.split(‘[\W]+’, ‘Words, words, words.’, 1)<br>[‘Words’, ‘words, words.’]</pre><br>&nbsp;</p>
<h4 id="u641C_u7D22_u548C_u66FF_u6362"><a href="#u641C_u7D22_u548C_u66FF_u6362" class="headerlink" title="搜索和替换"></a><span class="mw-headline">搜索和替换 </span></h4><p>其他常见的用途就是找到所有模式匹配的字符串并用不同的字符串来替换它们。sub() 方法提供一个替换值，可以是字符串或一个函数，和一个要被处理的字符串。</p>
<p><pre>sub(replacement, string[, count = 0])<br></pre><br>返回的字符串是在字符串中用 RE 最左边不重复的匹配来替换。如果模式没有发现，字符将被没有改变地返回。<br>可选参数 count 是模式匹配后替换的最大次数；count 必须是非负整数。缺省值是 0 表示替换所有的匹配。<br>这里有个使用 sub() 方法的简单例子。它用单词 “colour” 替换颜色名。</p>
<p><pre class="lang:default decode:true">#!python<br>&gt;&gt;&gt; p = re.compile( ‘(blue|white|red)’)<br>&gt;&gt;&gt; p.sub( ‘colour’, ‘blue socks and red shoes’)<br>‘colour socks and colour shoes’<br>&gt;&gt;&gt; p.sub( ‘colour’, ‘blue socks and red shoes’, count=1)<br>‘colour socks and red shoes’</pre><br>subn() 方法作用一样，但返回的是包含新字符串和替换执行次数的两元组。</p>
<p><pre class="lang:default decode:true">#!python<br>&gt;&gt;&gt; p = re.compile( ‘(blue|white|red)’)<br>&gt;&gt;&gt; p.subn( ‘colour’, ‘blue socks and red shoes’)<br>(‘colour socks and colour shoes’, 2)<br>&gt;&gt;&gt; p.subn( ‘colour’, ‘no colours at all’)<br>(‘no colours at all’, 0)</pre><br>空匹配只有在它们没有紧挨着前一个匹配时才会被替换掉。</p>
<p><pre class="lang:default decode:true">#!python<br>&gt;&gt;&gt; p = re.compile(‘x*’)<br>&gt;&gt;&gt; p.sub(‘-‘, ‘abxd’)<br>‘-a-b-d-‘</pre><br>如果替换的是一个字符串，任何在其中的反斜杠都会被处理。”\n” 将会被转换成一个换行符，”\r”转换成回车等等。未知的转义如 “\j” 则保持原样。逆向引用，如 “\6”，被 RE 中相应的组匹配而被子串替换。这使你可以在替换后的字符串中插入原始文本的一部分。<br>这个例子匹配被 “{“ 和 “}” 括起来的单词 “section”，并将 “section” 替换成 “subsection”。</p>
<p><pre class="lang:default decode:true">#!python<br>&gt;&gt;&gt; p = re.compile(‘section{ ( [^}]* ) }’, re.VERBOSE)<br>&gt;&gt;&gt; p.sub(r’subsection{\1}’,’section{First} section{second}’)<br>‘subsection{First} subsection{second}’</pre><br>还可以指定用 (?P&lt;name&gt;…) 语法定义的命名组。”\g&lt;name&gt;” 将通过组名 “name” 用子串来匹配，并且 “\g&lt;number&gt;” 使用相应的组号。所以 “\g&lt;2&gt;” 等于 “\2”，但能在替换字符串里含义不清，如 “\g&lt;2&gt;0”。（”\20” 被解释成对组 20 的引用，而不是对后面跟着一个字母 “0” 的组 2 的引用。）</p>
<p><pre class="lang:default decode:true">#!python<br>&gt;&gt;&gt; p = re.compile(‘section{ (?P&lt;name&gt; [^}]* ) }’, re.VERBOSE)<br>&gt;&gt;&gt; p.sub(r’subsection{\1}’,’section{First}’)<br>‘subsection{First}’<br>&gt;&gt;&gt; p.sub(r’subsection{\g&lt;1&gt;}’,’section{First}’)<br>‘subsection{First}’<br>&gt;&gt;&gt; p.sub(r’subsection{\g&lt;name&gt;}’,’section{First}’)<br>‘subsection{First}’</pre><br>替换也可以是一个甚至给你更多控制的函数。如果替换是个函数，该函数将会被模式中每一个不重复的匹配所调用。在每次调用时，函数会被传入一个 <code>MatchObject</code> 的对象作为参数，因此可以用这个对象去计算出替换字符串并返回它。<br>在下面的例子里，替换函数将十进制翻译成十六进制：</p>
<p><pre class="lang:default decode:true">#!python<br>&gt;&gt;&gt; def hexrepl( match ):<br>…     “Return the hex string for a decimal number”<br>…     value = int( match.group() )<br>…     return hex(value)<br>…<br>&gt;&gt;&gt; p = re.compile(r’\d+’)<br>&gt;&gt;&gt; p.sub(hexrepl, ‘Call 65490 for printing, 49152 for user code.’)<br>‘Call 0xffd2 for printing, 0xc000 for user code.’</pre><br>当使用模块级的 re.sub() 函数时，模式作为第一个参数。模式也许是一个字符串或一个 <code>RegexObject</code>；如果你需要指定正则表达式标志，你必须要么使用 <code>RegexObject</code> 做第一个参数，或用使用模式内嵌修正器，如 sub(“(?i)b+”, “x”, “bbbb BBBB”) returns ‘x x’。</p>
<p>&nbsp;</p>
<h3 id="u5E38_u89C1_u95EE_u9898"><a href="#u5E38_u89C1_u95EE_u9898" class="headerlink" title="常见问题"></a><span class="mw-headline">常见问题 </span></h3><p>正则表达式对一些应用程序来说是一个强大的工具，但在有些时候它并不直观而且有时它们不按你期望的运行。本节将指出一些最容易犯的常见错误。</p>
<p>&nbsp;</p>
<h4 id="u4F7F_u7528_u5B57_u7B26_u4E32_u65B9_u5F0F"><a href="#u4F7F_u7528_u5B57_u7B26_u4E32_u65B9_u5F0F" class="headerlink" title="使用字符串方式"></a><span class="mw-headline">使用字符串方式 </span></h4><p>有时使用 re 模块是个错误。如果你匹配一个固定的字符串或单个的字符类，并且你没有使用 re 的任何象 IGNORECASE 标志的功能，那么就没有必要使用正则表达式了。字符串有一些方法是对固定字符串进行操作的，它们通常快很多，因为它们都是一个个经过优化的 C 小循环，用以代替大的、更具通用性的正则表达式引擎。<br>举个 用一个固定字符串替换另一个 的例子，如：你可以把 “deed” 替换成 “word”。re.sub() 似乎正是胜任这个工作的函数，但还是考虑考虑 replace() 方法吧。注意 replace() 也可以在单词里面进行替换，可以把 “swordfish” 变成 “sdeedfish”。不过 RE 也是可以做到的。（为了避免替换单词的一部分，模式将写成 \bword\b，这是为了要求 “word” 两边有一个单词边界。这是个超出 replace 能力的工作）。<br>另一个常见任务是从一个字符串中删除单个字符或用另一个字符来替代它。你也许可以用 re.sub(‘\n’,’ ‘, s) 这样来实现，但 translate() 能够实现这两个任务，而且比任何正则表达式操作起来更快。 （translate 需要配合 string.maketrans 使用。例如：import string 后 ‘a1b3’.translate(string.maketrans(‘ab’, ‘cd’)) ）</p>
<p>总之，在使用 re 模块之前，先考虑一下你的问题是否可以用更快、更简单的字符串方法来解决。</p>
<p>&nbsp;</p>
<h4 id="match_28_29_vs_search_28_29"><a href="#match_28_29_vs_search_28_29" class="headerlink" title="match() vs search()"></a><span class="mw-headline">match() vs search() </span></h4><p>match() 函数只检查 RE 是否在字符串开始处匹配，而 search() 则是扫描整个字符串。记住这一区别是重要的。记住，match() 只报告一次成功的匹配，它将从 0 处开始；如果匹配不是从 0 开始的，match() 将不会报告它。</p>
<p><pre class="lang:default decode:true">#!python<br>&gt;&gt;&gt; print re.match(‘super’, ‘superstition’).span()<br>(0, 5)<br>&gt;&gt;&gt; print re.match(‘super’, ‘insuperable’)<br>None</pre><br>另一方面，search() 将扫描整个字符串，并报告它找到的第一个匹配。</p>
<p><pre class="lang:default decode:true">#!python<br>&gt;&gt;&gt; print re.search(‘super’, ‘superstition’).span()<br>(0, 5)<br>&gt;&gt;&gt; print re.search(‘super’, ‘insuperable’).span()<br>(2, 7)</pre><br>有时你可能倾向于使用 re.match()，只在RE的前面部分添加 .* 。请尽量不要这么做，最好采用 re.search() 代替之。正则表达式编译器会对 REs 做一些分析以便可以在查找匹配时提高处理速度。一个那样的分析机会指出匹配的第一个字符是什么；举个例子，模式 Crow 必须从 “C” 开始匹配。分析机可以让引擎快速扫描字符串以找到开始字符，并只在 “C” 被发现后才开始全部匹配。</p>
<p>添加 .* 会使这个优化失败，这就要扫描到字符串尾部，然后回溯以找到 RE 剩余部分的匹配。使用 re.search() 代替。</p>
<p>&nbsp;</p>
<h4 id="u8D2A_u5A6A_vs__u4E0D_u8D2A_u5A6A"><a href="#u8D2A_u5A6A_vs__u4E0D_u8D2A_u5A6A" class="headerlink" title="贪婪 vs 不贪婪"></a><span class="mw-headline">贪婪 vs 不贪婪 </span></h4><p>当重复一个正则表达式时，如用 a<em>，操作结果是尽可能多地匹配模式。当你试着匹配一对对称的定界符，如 HTML 标志中的尖括号时这个事实经常困扰你。匹配单个 HTML 标志的模式不能正常工作，因为 .</em> 的本质是“贪婪”的</p>
<p><pre class="lang:default decode:true">#!python<br>&gt;&gt;&gt; s = ‘&lt;html&gt;&lt;head&gt;&lt;title&gt;Title&lt;/title&gt;’<br>&gt;&gt;&gt; len(s)<br>32<br>&gt;&gt;&gt; print re.match(‘&lt;.<em>&gt;’, s).span()<br>(0, 32)<br>&gt;&gt;&gt; print re.match(‘&lt;.</em>&gt;’, s).group()<br>&lt;html&gt;&lt;head&gt;&lt;title&gt;Title&lt;/title&gt;</pre><br>RE 匹配 在 “<code>&amp;lt;html&amp;gt;</code>“ 中的 “&lt;”，.<em> 消耗掉字符串的剩余部分。在 RE 中保持更多的左，虽然 &gt; 不能匹配在字符串结尾，因此正则表达式必须一个字符一个字符地回溯，直到它找到 &gt; 的匹配。最终的匹配从 “&lt;html” 中的 “&lt;” 到 “&lt;/title&gt;” 中的 “&gt;”,这并不是你所想要的结果。<br>在这种情况下，解决方案是使用不贪婪的限定符 </em>?、+?、?? 或 {m,n}?，尽可能匹配小的文本。在上面的例子里， “&gt;” 在第一个 “&lt;” 之后被立即尝试，当它失败时，引擎一次增加一个字符，并在每步重试 “&gt;”。这个处理将得到正确的结果：</p>
<p><pre class="lang:default decode:true ">#!python<br>&gt;&gt;&gt; print re.match(‘&lt;.*?&gt;’, s).group()<br>&lt;html&gt;</pre><br>注意用正则表达式分析 HTML 或 XML 是痛苦的。变化混乱的模式将处理常见情况，但 HTML 和 XML 则是明显会打破正则表达式的特殊情况；当你编写一个正则表达式去处理所有可能的情况时，模式将变得非常复杂。象这样的任务用 HTML 或 XML 解析器。</p>
<p><em><strong>粗体文字</strong></em>粗体文字’</p>
<p>&nbsp;</p>
<h4 id="u4E0D_u7528_re-VERBOSE"><a href="#u4E0D_u7528_re-VERBOSE" class="headerlink" title="不用 re.VERBOSE"></a><span class="mw-headline">不用 re.VERBOSE</span></h4><p>现在你可能注意到正则表达式的表示是十分紧凑，但它们非常不好读。中度复杂的 REs 可以变成反斜杠、圆括号和元字符的长长集合，以致于使它们很难读懂。<br>在这些 REs 中，当编译正则表达式时指定 re.VERBOSE 标志是有帮助的，因为它允许你可以编辑正则表达式的格式使之更清楚。<br>re.VERBOSE 标志有这么几个作用。在正则表达式中不在字符类中的空白符被忽略。这就意味着象 dog | cat 这样的表达式和可读性差的 dog|cat 相同，但 [a b] 将匹配字符 “a”、”b” 或 空格。另外，你也可以把注释放到 RE 中；注释是从 “#” 到下一行。当使用三引号字符串时，可以使 REs 格式更加干净：</p>
<p><pre>#!python<br>pat = re.compile(r”””<br>\s<em>                 # Skip leading whitespace<br>(?P&lt;header&gt;[^:]+)   # Header name<br>\s</em> :               # Whitespace, and a colon<br>(?P&lt;value&gt;.<em>?)      # The header’s value – </em>? used to</pre></p>
<h1 id="lose_the_following_trailing_whitespace"><a href="#lose_the_following_trailing_whitespace" class="headerlink" title="lose the following trailing whitespace"></a>lose the following trailing whitespace</h1><p>\s*$                # Trailing whitespace to end-of-line<br>“””, re.VERBOSE)<br><br>这个要难读得多：</p>
<p><pre>#!python<br>pat = re.compile(r”\s<em>(?P&lt;header&gt;[^:]+)\s</em>:(?P&lt;value&gt;.<em>?)\s</em>$”)<br></pre></p>
<blockquote>
<p><em>原文出处：<a href="http://www.amk.ca/python/howto/regex/" title="http://www.amk.ca/python/howto/regex/" target="_blank" rel="external">http://www.amk.ca/python/howto/regex/</a></em></p>
<p><em>原文作者：A.M. Kuchling （amk@amk.ca）</em></p>
<p><em>授权许可：<a href="http://www.creativecommons.cn/licenses/by-nc-sa/1.0/" title="http://www.creativecommons.cn/licenses/by-nc-sa/1.0/" target="_blank" rel="external">创作共用协议</a></em></p>
<p><em>翻译人员：FireHare</em></p>
<p><em>校对人员：<a href="https://wiki.ubuntu.org.cn/Leal" title="Leal" target="_blank" rel="external">Leal</a></em></p>
<p><em>适用版本：Python 1.5 及后续版本</em></p>
<p><em>相关链接：</em></p>
<p><a href="http://www.cnblogs.com/huxi/archive/2010/07/04/1771073.html" target="_blank" rel="external">   <em>   Python正则表达式指南</em></a></p>
<p><em><a href="http://cuiqingcai.com/977.html" target="_blank" rel="external">      Python爬虫入门七之正则表达式</a></em></p>
<p><em><a href="http://www.runoob.com/python/python-reg-expressions.html" target="_blank" rel="external">      Python正则表达式</a></em></p>
</blockquote>
  
	</div>
		<footer class="article-footer clearfix">

  <div class="article-tags">
  
  <span></span> <a href="/tags/Python/">Python</a><a href="/tags/Re/">Re</a>
  </div>


<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/Python/">Python</a>
</div>



<div class="article-share" id="share">

  <div data-url="http://blog.suzf.net/2016/04/22/Python正则表达式操作指南/" data-title="Python正则表达式操作指南 | Suzf Blog" data-tsina="null" class="share clearfix">
  </div>

</div>
</footer>   	       
	</article>
	
<nav class="article-nav clearfix">
 
 <div class="prev" >
 <a href="/2016/04/24/Python_Re_module_learn/" title="Python Re module learn">
  <strong>PREVIOUS:</strong><br/>
  <span>
  Python Re module learn</span>
</a>
</div>


<div class="next">
<a href="/2016/04/18/Hello_Kafka/"  title="Hello Kafka">
 <strong>NEXT:</strong><br/> 
 <span>Hello Kafka
</span>
</a>
</div>

</nav>

	
<section class="comment">
	<div class="ds-thread"></div>
</section>

</div>  
      <div class="openaside"><a class="navbutton" href="#" title="Show Sidebar"></a></div>

  <div id="toc" class="toc-aside">
  <strong class="toc-title">Contents</strong>
  <ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#u7B80_u4ECB"><span class="toc-number">1.</span> <span class="toc-text">简介 </span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#u7B80_u5355_u6A21_u5F0F"><span class="toc-number">2.</span> <span class="toc-text">简单模式 </span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#u5B57_u7B26_u5339_u914D"><span class="toc-number">2.1.</span> <span class="toc-text"> 字符匹配 </span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#u6A21_u5757_u7EA7_u51FD_u6570"><span class="toc-number">2.2.</span> <span class="toc-text">模块级函数 </span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#u7F16_u8BD1_u6807_u5FD7"><span class="toc-number">2.3.</span> <span class="toc-text">编译标志 </span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#u66F4_u591A_u6A21_u5F0F_u529F_u80FD"><span class="toc-number">3.</span> <span class="toc-text">更多模式功能 </span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#u66F4_u591A_u7684_u5143_u5B57_u7B26"><span class="toc-number">3.1.</span> <span class="toc-text">更多的元字符 </span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#u5206_u7EC4"><span class="toc-number">3.2.</span> <span class="toc-text">分组 </span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#u65E0_u6355_u83B7_u7EC4_u548C_u547D_u540D_u7EC4"><span class="toc-number">3.3.</span> <span class="toc-text">无捕获组和命名组 </span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#u524D_u5411_u754C_u5B9A_u7B26"><span class="toc-number">3.4.</span> <span class="toc-text">前向界定符 </span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#u4FEE_u6539_u5B57_u7B26_u4E32"><span class="toc-number">4.</span> <span class="toc-text">修改字符串 </span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#u5C06_u5B57_u7B26_u4E32_u5206_u7247"><span class="toc-number">4.1.</span> <span class="toc-text">将字符串分片 </span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#u641C_u7D22_u548C_u66FF_u6362"><span class="toc-number">4.2.</span> <span class="toc-text">搜索和替换 </span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#u5E38_u89C1_u95EE_u9898"><span class="toc-number">5.</span> <span class="toc-text">常见问题 </span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#u4F7F_u7528_u5B57_u7B26_u4E32_u65B9_u5F0F"><span class="toc-number">5.1.</span> <span class="toc-text">使用字符串方式 </span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#match_28_29_vs_search_28_29"><span class="toc-number">5.2.</span> <span class="toc-text">match() vs search() </span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#u8D2A_u5A6A_vs__u4E0D_u8D2A_u5A6A"><span class="toc-number">5.3.</span> <span class="toc-text">贪婪 vs 不贪婪 </span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#u4E0D_u7528_re-VERBOSE"><span class="toc-number">5.4.</span> <span class="toc-text">不用 re.VERBOSE</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#lose_the_following_trailing_whitespace"><span class="toc-number"></span> <span class="toc-text">lose the following trailing whitespace</span></a>
  </div>

<div id="asidepart">
<div class="closeaside"><a class="closebutton" href="#" title="Hide Sidebar"></a></div>
<aside class="clearfix">

  
<div class="categorieslist">
	<p class="asidetitle">Categories</p>
		<ul>
		
			<li><a href="/categories/Apache/" title="Apache">Apache<sup>1</sup></a></li>
		
			<li><a href="/categories/Auto-ops/" title="Auto ops">Auto ops<sup>3</sup></a></li>
		
			<li><a href="/categories/CouchBase/" title="CouchBase">CouchBase<sup>1</sup></a></li>
		
			<li><a href="/categories/HA/" title="HA">HA<sup>1</sup></a></li>
		
			<li><a href="/categories/Hadoop/" title="Hadoop">Hadoop<sup>6</sup></a></li>
		
			<li><a href="/categories/Hardware/" title="Hardware">Hardware<sup>1</sup></a></li>
		
			<li><a href="/categories/Highcharts/" title="Highcharts">Highcharts<sup>1</sup></a></li>
		
			<li><a href="/categories/LVS/" title="LVS">LVS<sup>1</sup></a></li>
		
			<li><a href="/categories/Life/" title="Life">Life<sup>3</sup></a></li>
		
			<li><a href="/categories/Linux/" title="Linux">Linux<sup>28</sup></a></li>
		
			<li><a href="/categories/MongoDB/" title="MongoDB">MongoDB<sup>3</sup></a></li>
		
			<li><a href="/categories/Mysql/" title="Mysql">Mysql<sup>10</sup></a></li>
		
			<li><a href="/categories/Nginx/" title="Nginx">Nginx<sup>5</sup></a></li>
		
			<li><a href="/categories/Oracle/" title="Oracle">Oracle<sup>2</sup></a></li>
		
			<li><a href="/categories/PHP/" title="PHP">PHP<sup>1</sup></a></li>
		
			<li><a href="/categories/Puppet/" title="Puppet">Puppet<sup>6</sup></a></li>
		
			<li><a href="/categories/Python/" title="Python">Python<sup>23</sup></a></li>
		
			<li><a href="/categories/Redis/" title="Redis">Redis<sup>7</sup></a></li>
		
			<li><a href="/categories/Shell/" title="Shell">Shell<sup>2</sup></a></li>
		
			<li><a href="/categories/Tomcat/" title="Tomcat">Tomcat<sup>1</sup></a></li>
		
			<li><a href="/categories/Web/" title="Web">Web<sup>5</sup></a></li>
		
			<li><a href="/categories/Zabbix/" title="Zabbix">Zabbix<sup>13</sup></a></li>
		
		</ul>
</div>


  
<div class="tagslist">
	<p class="asidetitle">Tags</p>
		<ul class="clearfix">
		
			<li><a href="/tags/Apache/" title="Apache">Apache<sup>1</sup></a></li>
		
			<li><a href="/tags/CMD/" title="CMD">CMD<sup>1</sup></a></li>
		
			<li><a href="/tags/Ceph/" title="Ceph">Ceph<sup>2</sup></a></li>
		
			<li><a href="/tags/Debian/" title="Debian">Debian<sup>1</sup></a></li>
		
			<li><a href="/tags/ELK/" title="ELK">ELK<sup>1</sup></a></li>
		
			<li><a href="/tags/Exsi/" title="Exsi">Exsi<sup>1</sup></a></li>
		
			<li><a href="/tags/Flask/" title="Flask">Flask<sup>1</sup></a></li>
		
			<li><a href="/tags/GTID/" title="GTID">GTID<sup>2</sup></a></li>
		
			<li><a href="/tags/Kernel/" title="Kernel">Kernel<sup>2</sup></a></li>
		
			<li><a href="/tags/Kickstart/" title="Kickstart">Kickstart<sup>1</sup></a></li>
		
			<li><a href="/tags/LB/" title="LB">LB<sup>1</sup></a></li>
		
			<li><a href="/tags/LVS/" title="LVS">LVS<sup>1</sup></a></li>
		
			<li><a href="/tags/Life/" title="Life">Life<sup>1</sup></a></li>
		
			<li><a href="/tags/Linux/" title="Linux">Linux<sup>1</sup></a></li>
		
			<li><a href="/tags/Lnmp/" title="Lnmp">Lnmp<sup>1</sup></a></li>
		
			<li><a href="/tags/Log/" title="Log">Log<sup>1</sup></a></li>
		
			<li><a href="/tags/MongoDB/" title="MongoDB">MongoDB<sup>3</sup></a></li>
		
			<li><a href="/tags/Mysql/" title="Mysql">Mysql<sup>15</sup></a></li>
		
			<li><a href="/tags/Nginx/" title="Nginx">Nginx<sup>8</sup></a></li>
		
			<li><a href="/tags/NoSQL/" title="NoSQL">NoSQL<sup>4</sup></a></li>
		
		</ul>
</div>


</aside>
</div>
    </div>
    <footer><div id="footer" >
	
	<div class="line">
		<span></span>
		<div class="author"></div>
	</div>
	
	
	<section class="info">
		<p> Hello, I&#39;m a linuser. <br/>
			This is my blog, share with you. ^_^</p>
	</section>
	 
	<div class="social-font clearfix">
		
		
		
		<a href="https://github.com/oceanszf" target="_blank" title="github"></a>
		
		
		
	</div>
    <p class="copyright">Copyright © 2016 <a href="http://suzf.net" target="_blank" title="SUZF.NET">SUZF.NET</a> All Rights Reserved.
<!--		
		<a href="http://blog.suzf.net" target="_blank" title="Jeffrey Su">Jeffrey Su</a>
		
        -->
		</p>
</div>
</footer>
    <script src="/js/jquery-2.1.0.min.js"></script>
<script type="text/javascript">
$(document).ready(function(){ 
  $('.navbar').click(function(){
    $('header nav').toggleClass('shownav');
  });
  var myWidth = 0;
  function getSize(){
    if( typeof( window.innerWidth ) == 'number' ) {
      myWidth = window.innerWidth;
    } else if( document.documentElement && document.documentElement.clientWidth) {
      myWidth = document.documentElement.clientWidth;
    };
  };
  var m = $('#main'),
      a = $('#asidepart'),
      c = $('.closeaside'),
      o = $('.openaside');
  $(window).resize(function(){
    getSize(); 
    if (myWidth >= 1024) {
      $('header nav').removeClass('shownav');
    }else
    {
      m.removeClass('moveMain');
      a.css('display', 'block').removeClass('fadeOut');
      o.css('display', 'none');
      
      $('#toc.toc-aside').css('display', 'none');
        
    }
  });
  c.click(function(){
    a.addClass('fadeOut').css('display', 'none');
    o.css('display', 'block').addClass('fadeIn');
    m.addClass('moveMain');
  });
  o.click(function(){
    o.css('display', 'none').removeClass('beforeFadeIn');
    a.css('display', 'block').removeClass('fadeOut').addClass('fadeIn');      
    m.removeClass('moveMain');
  });
  $(window).scroll(function(){
    o.css("top",Math.max(80,260-$(this).scrollTop()));
  });
});
</script>

<script type="text/javascript">
$(document).ready(function(){ 
  var ai = $('.article-content>iframe'),
      ae = $('.article-content>embed'),
      t  = $('#toc'),
      h  = $('article h2')
      ah = $('article h2'),
      ta = $('#toc.toc-aside'),
      o  = $('.openaside'),
      c  = $('.closeaside');
  if(ai.length>0){
    ai.wrap('<div class="video-container" />');
  };
  if(ae.length>0){
   ae.wrap('<div class="video-container" />');
  };
  if(ah.length==0){
    t.css('display','none');
  }else{
    c.click(function(){
      ta.css('display', 'block').addClass('fadeIn');
    });
    o.click(function(){
      ta.css('display', 'none');
    });
    $(window).scroll(function(){
      ta.css("top",Math.max(140,320-$(this).scrollTop()));
    });
  };
});
</script>


<script type="text/javascript">
$(document).ready(function(){ 
  var $this = $('.share'),
      url = $this.attr('data-url'),
      encodedUrl = encodeURIComponent(url),
      title = $this.attr('data-title'),
      tsina = $this.attr('data-tsina');
  var html = [
  '<a href="#" class="overlay" id="qrcode"></a>',
  '<div class="qrcode clearfix"><span>扫描二维码分享到微信朋友圈</span><a class="qrclose" href="#share"></a><strong>Loading...Please wait</strong><img id="qrcode-pic" data-src="http://s.jiathis.com/qrcode.php?url=' + encodedUrl + '"/></div>',
  '<a href="#textlogo" class="article-back-to-top" title="Top"></a>',
  '<a href="https://www.facebook.com/sharer.php?u=' + encodedUrl + '" class="article-share-facebook" target="_blank" title="Facebook"></a>',
  '<a href="#qrcode" class="article-share-qrcode" title="QRcode"></a>',
  '<a href="https://twitter.com/intent/tweet?url=' + encodedUrl + '" class="article-share-twitter" target="_blank" title="Twitter"></a>',
  '<a href="http://service.weibo.com/share/share.php?title='+title+'&url='+encodedUrl +'&ralateUid='+ tsina +'&searchPic=true&style=number' +'" class="article-share-weibo" target="_blank" title="Weibo"></a>',
  '<span title="Share to"></span>'
  ].join('');
  $this.append(html);
  $('.article-share-qrcode').click(function(){
    var imgSrc = $('#qrcode-pic').attr('data-src');
    $('#qrcode-pic').attr('src', imgSrc);
    $('#qrcode-pic').load(function(){
        $('.qrcode strong').text(' ');
    });
  });
});     
</script>


<script type="text/javascript">
  var duoshuoQuery = {short_name:"Comment"};
  (function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0] 
    || document.getElementsByTagName('body')[0]).appendChild(ds);
  })();
</script> 





  </body>
</html>

